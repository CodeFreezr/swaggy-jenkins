/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class GetClassesByClass {
    'classes': Array<string>;
    'class': string;
}

export class GetMultibranchPipeline {
    'displayName': string;
    'estimatedDurationInMillis': number;
    'latestRun': string;
    'name': string;
    'organization': string;
    'weatherScore': number;
    'branchNames': Array<string>;
    'numberOfFailingBranches': number;
    'numberOfFailingPullRequests': number;
    'numberOfSuccessfulBranches': number;
    'numberOfSuccessfulPullRequests': number;
    'totalNumberOfBranches': number;
    'totalNumberOfPullRequests': number;
    'class': string;
}

export class GetOrganisations extends Array<SwaggyjenkinsOrganisation> {
}

export class GetPipelineBranches extends Array<GetPipelineBranchesitem> {
}

export class GetPipelineBranchesitem {
    'displayName': string;
    'estimatedDurationInMillis': number;
    'name': string;
    'weatherScore': number;
    'latestRun': GetPipelineBranchesitemLatestRun;
    'organization': string;
    'pullRequest': GetPipelineBranchesitemPullRequest;
    'totalNumberOfPullRequests': number;
    'class': string;
}

export class GetPipelineBranchesitemLatestRun {
    'durationInMillis': number;
    'estimatedDurationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;
    'class': string;
}

export class GetPipelineBranchesitemPullRequest {
    'links': GetPipelineBranchesitemPullRequestLinks;
    'author': string;
    'id': string;
    'title': string;
    'url': string;
    'class': string;
}

export class GetPipelineBranchesitemPullRequestLinks {
    'self': string;
    'class': string;
}

export class GetPipelines extends Array<SwaggyjenkinsPipeline> {
}

export class GetUsers extends Array<SwaggyjenkinsUser> {
}

export class HudsonmodelAllView {
    'class': string;
    'name': string;
    'url': string;
}

export class HudsonmodelCauseAction {
    'class': string;
    'causes': Array<HudsonmodelCauseUserIdCause>;
}

export class HudsonmodelCauseUserIdCause {
    'class': string;
    'shortDescription': string;
    'userId': string;
    'userName': string;
}

export class HudsonmodelComputerSet {
    'class': string;
    'busyExecutors': number;
    'computer': Array<HudsonmodelHudsonMasterComputer>;
    'displayName': string;
    'totalExecutors': number;
}

export class HudsonmodelFreeStyleBuild {
    'class': string;
    'number': number;
    'url': string;
    'actions': Array<HudsonmodelCauseAction>;
    'building': boolean;
    'description': string;
    'displayName': string;
    'duration': number;
    'estimatedDuration': number;
    'executor': string;
    'fullDisplayName': string;
    'id': string;
    'keepLog': boolean;
    'queueId': number;
    'result': string;
    'timestamp': number;
    'builtOn': string;
    'changeSet': HudsonscmEmptyChangeLogSet;
}

export class HudsonmodelFreeStyleProject {
    'class': string;
    'name': string;
    'url': string;
    'color': string;
    'actions': Array<HudsonmodelFreeStyleProjectactions>;
    'description': string;
    'displayName': string;
    'displayNameOrNull': string;
    'fullDisplayName': string;
    'fullName': string;
    'buildable': boolean;
    'builds': Array<HudsonmodelFreeStyleBuild>;
    'firstBuild': HudsonmodelFreeStyleBuild;
    'healthReport': Array<HudsonmodelFreeStyleProjecthealthReport>;
    'inQueue': boolean;
    'keepDependencies': boolean;
    'lastBuild': HudsonmodelFreeStyleBuild;
    'lastCompletedBuild': HudsonmodelFreeStyleBuild;
    'lastFailedBuild': string;
    'lastStableBuild': HudsonmodelFreeStyleBuild;
    'lastSuccessfulBuild': HudsonmodelFreeStyleBuild;
    'lastUnstableBuild': string;
    'lastUnsuccessfulBuild': string;
    'nextBuildNumber': number;
    'queueItem': string;
    'concurrentBuild': boolean;
    'scm': HudsonscmNullSCM;
}

export class HudsonmodelFreeStyleProjectactions {
    'class': string;
}

export class HudsonmodelFreeStyleProjecthealthReport {
    'description': string;
    'iconClassName': string;
    'iconUrl': string;
    'score': number;
    'class': string;
}

export class HudsonmodelHudson {
    'class': string;
    'assignedLabels': Array<HudsonmodelHudsonassignedLabels>;
    'mode': string;
    'nodeDescription': string;
    'nodeName': string;
    'numExecutors': number;
    'description': string;
    'jobs': Array<HudsonmodelFreeStyleProject>;
    'primaryView': HudsonmodelAllView;
    'quietingDown': boolean;
    'slaveAgentPort': number;
    'unlabeledLoad': JenkinsmodelUnlabeledLoadStatistics;
    'useCrumbs': boolean;
    'useSecurity': boolean;
    'views': Array<HudsonmodelAllView>;
}

export class HudsonmodelHudsonMasterComputer {
    'class': string;
    'displayName': string;
    'executors': Array<HudsonmodelHudsonMasterComputerexecutors>;
    'icon': string;
    'iconClassName': string;
    'idle': boolean;
    'jnlpAgent': boolean;
    'launchSupported': boolean;
    'loadStatistics': HudsonmodelLabel1;
    'manualLaunchAllowed': boolean;
    'monitorData': HudsonmodelHudsonMasterComputerMonitorData;
    'numExecutors': number;
    'offline': boolean;
    'offlineCause': string;
    'offlineCauseReason': string;
    'temporarilyOffline': boolean;
}

export class HudsonmodelHudsonMasterComputerMonitorData {
    'hudsonNodeMonitorsSwapSpaceMonitor': HudsonnodeMonitorsSwapSpaceMonitorMemoryUsage2;
    'hudsonNodeMonitorsTemporarySpaceMonitor': HudsonnodeMonitorsDiskSpaceMonitorDescriptorDiskSpace;
    'hudsonNodeMonitorsDiskSpaceMonitor': HudsonnodeMonitorsDiskSpaceMonitorDescriptorDiskSpace;
    'hudsonNodeMonitorsArchitectureMonitor': string;
    'hudsonNodeMonitorsResponseTimeMonitor': HudsonnodeMonitorsResponseTimeMonitorData;
    'hudsonNodeMonitorsClockMonitor': HudsonutilClockDifference;
    'class': string;
}

export class HudsonmodelHudsonMasterComputerexecutors {
    'currentExecutable': HudsonmodelFreeStyleBuild;
    'idle': boolean;
    'likelyStuck': boolean;
    'number': number;
    'progress': number;
    'class': string;
}

export class HudsonmodelHudsonassignedLabels {
    'class': string;
}

export class HudsonmodelLabel1 {
    'class': string;
}

export class HudsonmodelListView {
    'class': string;
    'description': string;
    'jobs': Array<HudsonmodelFreeStyleProject>;
    'name': string;
    'url': string;
}

export class HudsonmodelQueue {
    'class': string;
    'items': Array<HudsonmodelQueueBlockedItem>;
}

export class HudsonmodelQueueBlockedItem {
    'class': string;
    'actions': Array<HudsonmodelCauseAction>;
    'blocked': boolean;
    'buildable': boolean;
    'id': number;
    'inQueueSince': number;
    'params': string;
    'stuck': boolean;
    'task': HudsonmodelFreeStyleProject;
    'url': string;
    'why': string;
    'buildableStartMilliseconds': number;
}

export class HudsonmodelQueueLeftItem {
    'class': string;
    'actions': Array<HudsonmodelCauseAction>;
    'blocked': boolean;
    'buildable': boolean;
    'id': number;
    'inQueueSince': number;
    'params': string;
    'stuck': boolean;
    'task': HudsonmodelFreeStyleProject;
    'url': string;
    'why': string;
    'cancelled': boolean;
    'executable': HudsonmodelFreeStyleBuild;
}

export class HudsonmodelStringParameterDefinition {
    'class': string;
    'defaultParameterValue': HudsonmodelStringParameterValue;
    'description': string;
    'name': string;
    'type': string;
}

export class HudsonmodelStringParameterValue {
    'class': string;
    'name': string;
    'value': string;
}

export class HudsonnodeMonitorsDiskSpaceMonitorDescriptorDiskSpace {
    'class': string;
    'timestamp': number;
    'path': string;
    'size': number;
}

export class HudsonnodeMonitorsResponseTimeMonitorData {
    'class': string;
    'timestamp': number;
    'average': number;
}

export class HudsonnodeMonitorsSwapSpaceMonitorMemoryUsage2 {
    'class': string;
    'availablePhysicalMemory': number;
    'availableSwapSpace': number;
    'totalPhysicalMemory': number;
    'totalSwapSpace': number;
}

export class HudsonscmEmptyChangeLogSet {
    'class': string;
    'kind': string;
}

export class HudsonscmNullSCM {
    'class': string;
}

export class HudsonsecuritycsrfDefaultCrumbIssuer {
    'class': string;
    'crumb': string;
    'crumbRequestField': string;
}

export class HudsonutilClockDifference {
    'class': string;
    'diff': number;
}

export class IojenkinsblueoceanresthalLink {
    'class': string;
    'href': string;
}

export class IojenkinsblueoceanrestimplpipelineBranchImpl {
    'class': string;
    'displayName': string;
    'estimatedDurationInMillis': number;
    'fullDisplayName': string;
    'fullName': string;
    'name': string;
    'organization': string;
    'parameters': Array<HudsonmodelStringParameterDefinition>;
    'permissions': IojenkinsblueoceanrestimplpipelineBranchImplPermissions;
    'weatherScore': number;
    'pullRequest': string;
}

export class IojenkinsblueoceanrestimplpipelineBranchImplPermissions {
    'create': boolean;
    'read': boolean;
    'start': boolean;
    'stop': boolean;
    'class': string;
}

export class IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1 {
    'class': string;
    'links': IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Links;
    'map': IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Map;
}

export class IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Links {
    'self': IojenkinsblueoceanresthalLink;
    'class': string;
}

export class IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Map {
    'ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl': IojenkinsblueoceanserviceembeddedrestExtensionClassImpl;
    'ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl': IojenkinsblueoceanserviceembeddedrestExtensionClassImpl;
    'class': string;
}

export class IojenkinsblueoceanserviceembeddedrestExtensionClassImpl {
    'class': string;
    'links': IojenkinsblueoceanserviceembeddedrestExtensionClassImplLinks;
    'classes': Array<string>;
}

export class IojenkinsblueoceanserviceembeddedrestExtensionClassImplLinks {
    'self': IojenkinsblueoceanresthalLink;
    'class': string;
}

export class IojenkinsblueoceanserviceembeddedrestPipelineFolderImpl {
    'class': string;
    'displayName': string;
    'fullName': string;
    'name': string;
    'organization': string;
    'numberOfFolders': number;
    'numberOfPipelines': number;
}

export class IojenkinsblueoceanserviceembeddedrestPipelineImpl {
    'class': string;
    'displayName': string;
    'estimatedDurationInMillis': number;
    'fullName': string;
    'latestRun': string;
    'name': string;
    'organization': string;
    'weatherScore': number;
}

export class JenkinsmodelUnlabeledLoadStatistics {
    'class': string;
}

export class SwaggyjenkinsOrganisation {
    'class': string;
    'name': string;
}

export class SwaggyjenkinsPipeline {
    'class': string;
    'organization': string;
    'name': string;
    'displayName': string;
    'fullName': string;
    'weatherScore': number;
    'estimatedDurationInMillis': number;
    'latestRun': SwaggyjenkinsPipelineLatestRun;
}

export class SwaggyjenkinsPipelineLatestRun {
    'artifacts': Array<SwaggyjenkinsPipelineLatestRunartifacts>;
    'durationInMillis': number;
    'estimatedDurationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;
    'class': string;
}

export class SwaggyjenkinsPipelineLatestRunartifacts {
    'name': string;
    'size': number;
    'url': string;
    'class': string;
}

export class SwaggyjenkinsUser {
    'class': string;
    'id': string;
    'fullName': string;
    'email': string;
    'name': string;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum BlueOceanApiApiKeys {
}

export class BlueOceanApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jenkins_auth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: BlueOceanApiApiKeys, value: string) {
        this.authentications[BlueOceanApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.jenkins_auth.username = username;
    }

    set password(password: string) {
        this.authentications.jenkins_auth.password = password;
    }
    /**
     * 
     * Retrieve authenticated user details for an organisation
     * @param organisation Name of the organisation
     */
    public getAuthenticatedUser (organisation: string) : Promise<{ response: http.ClientResponse; body: SwaggyjenkinsUser;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/user/'
            .replace('{' + 'organisation' + '}', String(organisation));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getAuthenticatedUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SwaggyjenkinsUser;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    public getClasses (_class: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/classes/{class}'
            .replace('{' + 'class' + '}', String(_class));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter '_class' is not null or undefined
        if (_class === null || _class === undefined) {
            throw new Error('Required parameter _class was null or undefined when calling getClasses.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve organisation details
     * @param organisation Name of the organisation
     */
    public getOrganisation (organisation: string) : Promise<{ response: http.ClientResponse; body: SwaggyjenkinsOrganisation;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}'
            .replace('{' + 'organisation' + '}', String(organisation));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getOrganisation.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SwaggyjenkinsOrganisation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve all organisations details
     */
    public getOrganisations () : Promise<{ response: http.ClientResponse; body: GetOrganisations;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetOrganisations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve branch details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    public getPipelineBranchByOrg (organisation: string, pipeline: string, branch: string) : Promise<{ response: http.ClientResponse; body: IojenkinsblueoceanrestimplpipelineBranchImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/pipelines/{pipeline}/branches/{branch}/'
            .replace('{' + 'organisation' + '}', String(organisation))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'branch' + '}', String(branch));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineBranchByOrg.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranchByOrg.');
        }

        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling getPipelineBranchByOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IojenkinsblueoceanrestimplpipelineBranchImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve all branches details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    public getPipelineBranchesByOrg (organisation: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: GetMultibranchPipeline;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/pipelines/{pipeline}/branches'
            .replace('{' + 'organisation' + '}', String(organisation))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineBranchesByOrg.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranchesByOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetMultibranchPipeline;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve pipeline details for an organisation
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    public getPipelineByOrg (organisation: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: SwaggyjenkinsPipeline;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/pipelines/{pipeline}'
            .replace('{' + 'organisation' + '}', String(organisation))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineByOrg.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineByOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SwaggyjenkinsPipeline;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve pipeline folder for an organisation
     * @param organisation Name of the organisation
     * @param folder Name of the folder
     */
    public getPipelineFolderByOrg (organisation: string, folder: string) : Promise<{ response: http.ClientResponse; body: IojenkinsblueoceanserviceembeddedrestPipelineFolderImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/pipelines/{folder}/'
            .replace('{' + 'organisation' + '}', String(organisation))
            .replace('{' + 'folder' + '}', String(folder));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineFolderByOrg.');
        }

        // verify required parameter 'folder' is not null or undefined
        if (folder === null || folder === undefined) {
            throw new Error('Required parameter folder was null or undefined when calling getPipelineFolderByOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IojenkinsblueoceanserviceembeddedrestPipelineFolderImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve pipeline details for an organisation folder
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    public getPipelineFolderByOrg_1 (organisation: string, pipeline: string, folder: string) : Promise<{ response: http.ClientResponse; body: IojenkinsblueoceanserviceembeddedrestPipelineImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/pipelines/{folder}/pipelines/{pipeline}'
            .replace('{' + 'organisation' + '}', String(organisation))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'folder' + '}', String(folder));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineFolderByOrg_1.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineFolderByOrg_1.');
        }

        // verify required parameter 'folder' is not null or undefined
        if (folder === null || folder === undefined) {
            throw new Error('Required parameter folder was null or undefined when calling getPipelineFolderByOrg_1.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: IojenkinsblueoceanserviceembeddedrestPipelineImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve all pipelines details for an organisation
     * @param organisation Name of the organisation
     */
    public getPipelinesByOrg (organisation: string) : Promise<{ response: http.ClientResponse; body: GetPipelines;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/pipelines/'
            .replace('{' + 'organisation' + '}', String(organisation));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelinesByOrg.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetPipelines;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve user details for an organisation
     * @param organisation Name of the organisation
     * @param user Name of the user
     */
    public getUser (organisation: string, user: string) : Promise<{ response: http.ClientResponse; body: SwaggyjenkinsUser;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/users/{user}'
            .replace('{' + 'organisation' + '}', String(organisation))
            .replace('{' + 'user' + '}', String(user));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getUser.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUser.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SwaggyjenkinsUser;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve users details for an organisation
     * @param organisation Name of the organisation
     */
    public getUsers (organisation: string) : Promise<{ response: http.ClientResponse; body: SwaggyjenkinsUser;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organisation}/users/'
            .replace('{' + 'organisation' + '}', String(organisation));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getUsers.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SwaggyjenkinsUser;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Get classes details
     * @param q Query string containing an array of class names
     */
    public search (q: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/classes/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling search.');
        }

        if (q !== undefined) {
            queryParameters['q'] = q;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Search for any resource details
     * @param q Query string
     */
    public search_2 (q: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/search/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling search_2.');
        }

        if (q !== undefined) {
            queryParameters['q'] = q;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RemoteAccessApiApiKeys {
}

export class RemoteAccessApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jenkins_auth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setApiKey(key: RemoteAccessApiApiKeys, value: string) {
        this.authentications[RemoteAccessApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.jenkins_auth.username = username;
    }

    set password(password: string) {
        this.authentications.jenkins_auth.password = password;
    }
    /**
     * 
     * Retrieve computer details
     */
    public getComputer () : Promise<{ response: http.ClientResponse; body: HudsonmodelComputerSet;  }> {
        const localVarPath = this.basePath + '/computer/api/json?depth=1';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelComputerSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve CSRF protection token
     */
    public getCrumb () : Promise<{ response: http.ClientResponse; body: HudsonsecuritycsrfDefaultCrumbIssuer;  }> {
        const localVarPath = this.basePath + '/crumbIssuer/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonsecuritycsrfDefaultCrumbIssuer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve Jenkins details
     */
    public getJenkins () : Promise<{ response: http.ClientResponse; body: HudsonmodelHudson;  }> {
        const localVarPath = this.basePath + '/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelHudson;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve job details
     * @param name Name of the job
     */
    public getJob (name: string) : Promise<{ response: http.ClientResponse; body: HudsonmodelFreeStyleProject;  }> {
        const localVarPath = this.basePath + '/job/{name}/api/json'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJob.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelFreeStyleProject;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve job configuration
     * @param name Name of the job
     */
    public getJobConfig (name: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/job/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJobConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve job&#39;s last build details
     * @param name Name of the job
     */
    public getJobLastBuild (name: string) : Promise<{ response: http.ClientResponse; body: HudsonmodelFreeStyleBuild;  }> {
        const localVarPath = this.basePath + '/job/{name}/lastBuild/api/json'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJobLastBuild.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelFreeStyleBuild;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve job&#39;s build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    public getJobProgressiveText (name: string, number: string, start: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/{number}/logText/progressiveText'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'number' + '}', String(number));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJobProgressiveText.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getJobProgressiveText.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getJobProgressiveText.');
        }

        if (start !== undefined) {
            queryParameters['start'] = start;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve queue details
     */
    public getQueue () : Promise<{ response: http.ClientResponse; body: HudsonmodelQueue;  }> {
        const localVarPath = this.basePath + '/queue/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelQueue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve queued item details
     * @param number Queue number
     */
    public getQueueItem (number: string) : Promise<{ response: http.ClientResponse; body: HudsonmodelQueue;  }> {
        const localVarPath = this.basePath + '/queue/item/{number}/api/json'
            .replace('{' + 'number' + '}', String(number));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getQueueItem.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelQueue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve view details
     * @param name Name of the view
     */
    public getView (name: string) : Promise<{ response: http.ClientResponse; body: HudsonmodelListView;  }> {
        const localVarPath = this.basePath + '/view/{name}/api/json'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getView.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: HudsonmodelListView;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve view configuration
     * @param name Name of the view
     */
    public getViewConfig (name: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/view/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getViewConfig.');
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Retrieve Jenkins headers
     */
    public headJenkins () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    public postCreateItem (name: string, from?: string, mode?: string, body?: string, jenkinsCrumb?: string, contentType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/createItem';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postCreateItem.');
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        if (from !== undefined) {
            queryParameters['from'] = from;
        }

        if (mode !== undefined) {
            queryParameters['mode'] = mode;
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    public postCreateView (name: string, body?: string, jenkinsCrumb?: string, contentType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/createView';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postCreateView.');
        }

        if (name !== undefined) {
            queryParameters['name'] = name;
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        headerParams['Content-Type'] = contentType;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobBuild (name: string, json: string, token?: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/build'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobBuild.');
        }

        // verify required parameter 'json' is not null or undefined
        if (json === null || json === undefined) {
            throw new Error('Required parameter json was null or undefined when calling postJobBuild.');
        }

        if (json !== undefined) {
            queryParameters['json'] = json;
        }

        if (token !== undefined) {
            queryParameters['token'] = token;
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobConfig (name: string, body: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobConfig.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postJobConfig.');
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobDelete (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/doDelete'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobDelete.');
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobDisable (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/disable'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobDisable.');
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobEnable (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/enable'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobEnable.');
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobLastBuildStop (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/lastBuild/stop'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobLastBuildStop.');
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    public postViewConfig (name: string, body: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/view/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postViewConfig.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postViewConfig.');
        }

        headerParams['Jenkins-Crumb'] = jenkinsCrumb;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: body,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
