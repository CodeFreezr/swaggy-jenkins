/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AllView {
    'class': string;
    'name': string;
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AllView.attributeTypeMap;
    }
}

export class Body {
    'favorite': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "favorite",
            "baseName": "favorite",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Body.attributeTypeMap;
    }
}

export class BranchImpl {
    'class': string;
    'displayName': string;
    'estimatedDurationInMillis': number;
    'fullDisplayName': string;
    'fullName': string;
    'name': string;
    'organization': string;
    'parameters': Array<StringParameterDefinition>;
    'permissions': BranchImplpermissions;
    'weatherScore': number;
    'pullRequest': string;
    'links': BranchImpllinks;
    'latestRun': PipelineRunImpl;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "fullDisplayName",
            "baseName": "fullDisplayName",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<StringParameterDefinition>"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "BranchImplpermissions"
        },
        {
            "name": "weatherScore",
            "baseName": "weatherScore",
            "type": "number"
        },
        {
            "name": "pullRequest",
            "baseName": "pullRequest",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "BranchImpllinks"
        },
        {
            "name": "latestRun",
            "baseName": "latestRun",
            "type": "PipelineRunImpl"
        }    ];

    static getAttributeTypeMap() {
        return BranchImpl.attributeTypeMap;
    }
}

export class BranchImpllinks {
    'self': Link;
    'actions': Link;
    'runs': Link;
    'queue': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Link"
        },
        {
            "name": "runs",
            "baseName": "runs",
            "type": "Link"
        },
        {
            "name": "queue",
            "baseName": "queue",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchImpllinks.attributeTypeMap;
    }
}

export class BranchImplpermissions {
    'create': boolean;
    'read': boolean;
    'start': boolean;
    'stop': boolean;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "create",
            "baseName": "create",
            "type": "boolean"
        },
        {
            "name": "read",
            "baseName": "read",
            "type": "boolean"
        },
        {
            "name": "start",
            "baseName": "start",
            "type": "boolean"
        },
        {
            "name": "stop",
            "baseName": "stop",
            "type": "boolean"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BranchImplpermissions.attributeTypeMap;
    }
}

export class CauseAction {
    'class': string;
    'causes': Array<CauseUserIdCause>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "causes",
            "baseName": "causes",
            "type": "Array<CauseUserIdCause>"
        }    ];

    static getAttributeTypeMap() {
        return CauseAction.attributeTypeMap;
    }
}

export class CauseUserIdCause {
    'class': string;
    'shortDescription': string;
    'userId': string;
    'userName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CauseUserIdCause.attributeTypeMap;
    }
}

export class ClassesByClass {
    'classes': Array<string>;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "classes",
            "baseName": "classes",
            "type": "Array<string>"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ClassesByClass.attributeTypeMap;
    }
}

export class ClockDifference {
    'class': string;
    'diff': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "diff",
            "baseName": "diff",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ClockDifference.attributeTypeMap;
    }
}

export class ComputerSet {
    'class': string;
    'busyExecutors': number;
    'computer': Array<HudsonMasterComputer>;
    'displayName': string;
    'totalExecutors': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "busyExecutors",
            "baseName": "busyExecutors",
            "type": "number"
        },
        {
            "name": "computer",
            "baseName": "computer",
            "type": "Array<HudsonMasterComputer>"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "totalExecutors",
            "baseName": "totalExecutors",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ComputerSet.attributeTypeMap;
    }
}

export class DefaultCrumbIssuer {
    'class': string;
    'crumb': string;
    'crumbRequestField': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "crumb",
            "baseName": "crumb",
            "type": "string"
        },
        {
            "name": "crumbRequestField",
            "baseName": "crumbRequestField",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DefaultCrumbIssuer.attributeTypeMap;
    }
}

export class DiskSpaceMonitorDescriptorDiskSpace {
    'class': string;
    'timestamp': number;
    'path': string;
    'size': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return DiskSpaceMonitorDescriptorDiskSpace.attributeTypeMap;
    }
}

export class EmptyChangeLogSet {
    'class': string;
    'kind': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EmptyChangeLogSet.attributeTypeMap;
    }
}

export class ExtensionClassContainerImpl1 {
    'class': string;
    'links': ExtensionClassContainerImpl1links;
    'map': ExtensionClassContainerImpl1map;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "ExtensionClassContainerImpl1links"
        },
        {
            "name": "map",
            "baseName": "map",
            "type": "ExtensionClassContainerImpl1map"
        }    ];

    static getAttributeTypeMap() {
        return ExtensionClassContainerImpl1.attributeTypeMap;
    }
}

export class ExtensionClassContainerImpl1links {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExtensionClassContainerImpl1links.attributeTypeMap;
    }
}

export class ExtensionClassContainerImpl1map {
    'ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl': ExtensionClassImpl;
    'ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl': ExtensionClassImpl;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl",
            "baseName": "io.jenkins.blueocean.service.embedded.rest.PipelineImpl",
            "type": "ExtensionClassImpl"
        },
        {
            "name": "ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl",
            "baseName": "io.jenkins.blueocean.service.embedded.rest.MultiBranchPipelineImpl",
            "type": "ExtensionClassImpl"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExtensionClassContainerImpl1map.attributeTypeMap;
    }
}

export class ExtensionClassImpl {
    'class': string;
    'links': ExtensionClassImpllinks;
    'classes': Array<string>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "ExtensionClassImpllinks"
        },
        {
            "name": "classes",
            "baseName": "classes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ExtensionClassImpl.attributeTypeMap;
    }
}

export class ExtensionClassImpllinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ExtensionClassImpllinks.attributeTypeMap;
    }
}

export class FavoriteImpl {
    'class': string;
    'links': FavoriteImpllinks;
    'item': PipelineImpl;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "FavoriteImpllinks"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "PipelineImpl"
        }    ];

    static getAttributeTypeMap() {
        return FavoriteImpl.attributeTypeMap;
    }
}

export class FavoriteImpllinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FavoriteImpllinks.attributeTypeMap;
    }
}

export class FreeStyleBuild {
    'class': string;
    'number': number;
    'url': string;
    'actions': Array<CauseAction>;
    'building': boolean;
    'description': string;
    'displayName': string;
    'duration': number;
    'estimatedDuration': number;
    'executor': string;
    'fullDisplayName': string;
    'id': string;
    'keepLog': boolean;
    'queueId': number;
    'result': string;
    'timestamp': number;
    'builtOn': string;
    'changeSet': EmptyChangeLogSet;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<CauseAction>"
        },
        {
            "name": "building",
            "baseName": "building",
            "type": "boolean"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "duration",
            "baseName": "duration",
            "type": "number"
        },
        {
            "name": "estimatedDuration",
            "baseName": "estimatedDuration",
            "type": "number"
        },
        {
            "name": "executor",
            "baseName": "executor",
            "type": "string"
        },
        {
            "name": "fullDisplayName",
            "baseName": "fullDisplayName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "keepLog",
            "baseName": "keepLog",
            "type": "boolean"
        },
        {
            "name": "queueId",
            "baseName": "queueId",
            "type": "number"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "builtOn",
            "baseName": "builtOn",
            "type": "string"
        },
        {
            "name": "changeSet",
            "baseName": "changeSet",
            "type": "EmptyChangeLogSet"
        }    ];

    static getAttributeTypeMap() {
        return FreeStyleBuild.attributeTypeMap;
    }
}

export class FreeStyleProject {
    'class': string;
    'name': string;
    'url': string;
    'color': string;
    'actions': Array<FreeStyleProjectactions>;
    'description': string;
    'displayName': string;
    'displayNameOrNull': string;
    'fullDisplayName': string;
    'fullName': string;
    'buildable': boolean;
    'builds': Array<FreeStyleBuild>;
    'firstBuild': FreeStyleBuild;
    'healthReport': Array<FreeStyleProjecthealthReport>;
    'inQueue': boolean;
    'keepDependencies': boolean;
    'lastBuild': FreeStyleBuild;
    'lastCompletedBuild': FreeStyleBuild;
    'lastFailedBuild': string;
    'lastStableBuild': FreeStyleBuild;
    'lastSuccessfulBuild': FreeStyleBuild;
    'lastUnstableBuild': string;
    'lastUnsuccessfulBuild': string;
    'nextBuildNumber': number;
    'queueItem': string;
    'concurrentBuild': boolean;
    'scm': NullSCM;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "string"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<FreeStyleProjectactions>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "displayNameOrNull",
            "baseName": "displayNameOrNull",
            "type": "string"
        },
        {
            "name": "fullDisplayName",
            "baseName": "fullDisplayName",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "buildable",
            "baseName": "buildable",
            "type": "boolean"
        },
        {
            "name": "builds",
            "baseName": "builds",
            "type": "Array<FreeStyleBuild>"
        },
        {
            "name": "firstBuild",
            "baseName": "firstBuild",
            "type": "FreeStyleBuild"
        },
        {
            "name": "healthReport",
            "baseName": "healthReport",
            "type": "Array<FreeStyleProjecthealthReport>"
        },
        {
            "name": "inQueue",
            "baseName": "inQueue",
            "type": "boolean"
        },
        {
            "name": "keepDependencies",
            "baseName": "keepDependencies",
            "type": "boolean"
        },
        {
            "name": "lastBuild",
            "baseName": "lastBuild",
            "type": "FreeStyleBuild"
        },
        {
            "name": "lastCompletedBuild",
            "baseName": "lastCompletedBuild",
            "type": "FreeStyleBuild"
        },
        {
            "name": "lastFailedBuild",
            "baseName": "lastFailedBuild",
            "type": "string"
        },
        {
            "name": "lastStableBuild",
            "baseName": "lastStableBuild",
            "type": "FreeStyleBuild"
        },
        {
            "name": "lastSuccessfulBuild",
            "baseName": "lastSuccessfulBuild",
            "type": "FreeStyleBuild"
        },
        {
            "name": "lastUnstableBuild",
            "baseName": "lastUnstableBuild",
            "type": "string"
        },
        {
            "name": "lastUnsuccessfulBuild",
            "baseName": "lastUnsuccessfulBuild",
            "type": "string"
        },
        {
            "name": "nextBuildNumber",
            "baseName": "nextBuildNumber",
            "type": "number"
        },
        {
            "name": "queueItem",
            "baseName": "queueItem",
            "type": "string"
        },
        {
            "name": "concurrentBuild",
            "baseName": "concurrentBuild",
            "type": "boolean"
        },
        {
            "name": "scm",
            "baseName": "scm",
            "type": "NullSCM"
        }    ];

    static getAttributeTypeMap() {
        return FreeStyleProject.attributeTypeMap;
    }
}

export class FreeStyleProjectactions {
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FreeStyleProjectactions.attributeTypeMap;
    }
}

export class FreeStyleProjecthealthReport {
    'description': string;
    'iconClassName': string;
    'iconUrl': string;
    'score': number;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "iconClassName",
            "baseName": "iconClassName",
            "type": "string"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "number"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FreeStyleProjecthealthReport.attributeTypeMap;
    }
}

export class GenericResource {
    'class': string;
    'displayName': string;
    'durationInMillis': number;
    'id': string;
    'result': string;
    'startTime': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GenericResource.attributeTypeMap;
    }
}

export class GithubContent {
    'name': string;
    'sha': string;
    'class': string;
    'repo': string;
    'size': number;
    'owner': string;
    'path': string;
    'base64Data': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "sha",
            "baseName": "sha",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "repo",
            "baseName": "repo",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "owner",
            "baseName": "owner",
            "type": "string"
        },
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "base64Data",
            "baseName": "base64Data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubContent.attributeTypeMap;
    }
}

export class GithubFile {
    'content': GithubContent;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "GithubContent"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubFile.attributeTypeMap;
    }
}

export class GithubOrganization {
    'class': string;
    'links': GithubOrganizationlinks;
    'jenkinsOrganizationPipeline': boolean;
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "GithubOrganizationlinks"
        },
        {
            "name": "jenkinsOrganizationPipeline",
            "baseName": "jenkinsOrganizationPipeline",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubOrganization.attributeTypeMap;
    }
}

export class GithubOrganizationlinks {
    'repositories': Link;
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "repositories",
            "baseName": "repositories",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubOrganizationlinks.attributeTypeMap;
    }
}

export class GithubRepositories {
    'class': string;
    'links': GithubRepositorieslinks;
    'items': Array<GithubRepository>;
    'lastPage': number;
    'nextPage': number;
    'pageSize': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "GithubRepositorieslinks"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<GithubRepository>"
        },
        {
            "name": "lastPage",
            "baseName": "lastPage",
            "type": "number"
        },
        {
            "name": "nextPage",
            "baseName": "nextPage",
            "type": "number"
        },
        {
            "name": "pageSize",
            "baseName": "pageSize",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return GithubRepositories.attributeTypeMap;
    }
}

export class GithubRepositorieslinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubRepositorieslinks.attributeTypeMap;
    }
}

export class GithubRepository {
    'class': string;
    'links': GithubRepositorylinks;
    'defaultBranch': string;
    'description': string;
    'name': string;
    'permissions': GithubRepositorypermissions;
    'private': boolean;
    'fullName': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "GithubRepositorylinks"
        },
        {
            "name": "defaultBranch",
            "baseName": "defaultBranch",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "GithubRepositorypermissions"
        },
        {
            "name": "private",
            "baseName": "private",
            "type": "boolean"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubRepository.attributeTypeMap;
    }
}

export class GithubRepositorylinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubRepositorylinks.attributeTypeMap;
    }
}

export class GithubRepositorypermissions {
    'admin': boolean;
    'push': boolean;
    'pull': boolean;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "admin",
            "baseName": "admin",
            "type": "boolean"
        },
        {
            "name": "push",
            "baseName": "push",
            "type": "boolean"
        },
        {
            "name": "pull",
            "baseName": "pull",
            "type": "boolean"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubRepositorypermissions.attributeTypeMap;
    }
}

export class GithubRespositoryContainer {
    'class': string;
    'links': GithubRespositoryContainerlinks;
    'repositories': GithubRepositories;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "GithubRespositoryContainerlinks"
        },
        {
            "name": "repositories",
            "baseName": "repositories",
            "type": "GithubRepositories"
        }    ];

    static getAttributeTypeMap() {
        return GithubRespositoryContainer.attributeTypeMap;
    }
}

export class GithubRespositoryContainerlinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubRespositoryContainerlinks.attributeTypeMap;
    }
}

export class GithubScm {
    'class': string;
    'links': GithubScmlinks;
    'credentialId': string;
    'id': string;
    'uri': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "GithubScmlinks"
        },
        {
            "name": "credentialId",
            "baseName": "credentialId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubScm.attributeTypeMap;
    }
}

export class GithubScmlinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GithubScmlinks.attributeTypeMap;
    }
}

export class Hudson {
    'class': string;
    'assignedLabels': Array<HudsonassignedLabels>;
    'mode': string;
    'nodeDescription': string;
    'nodeName': string;
    'numExecutors': number;
    'description': string;
    'jobs': Array<FreeStyleProject>;
    'primaryView': AllView;
    'quietingDown': boolean;
    'slaveAgentPort': number;
    'unlabeledLoad': UnlabeledLoadStatistics;
    'useCrumbs': boolean;
    'useSecurity': boolean;
    'views': Array<AllView>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "assignedLabels",
            "baseName": "assignedLabels",
            "type": "Array<HudsonassignedLabels>"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "string"
        },
        {
            "name": "nodeDescription",
            "baseName": "nodeDescription",
            "type": "string"
        },
        {
            "name": "nodeName",
            "baseName": "nodeName",
            "type": "string"
        },
        {
            "name": "numExecutors",
            "baseName": "numExecutors",
            "type": "number"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "jobs",
            "baseName": "jobs",
            "type": "Array<FreeStyleProject>"
        },
        {
            "name": "primaryView",
            "baseName": "primaryView",
            "type": "AllView"
        },
        {
            "name": "quietingDown",
            "baseName": "quietingDown",
            "type": "boolean"
        },
        {
            "name": "slaveAgentPort",
            "baseName": "slaveAgentPort",
            "type": "number"
        },
        {
            "name": "unlabeledLoad",
            "baseName": "unlabeledLoad",
            "type": "UnlabeledLoadStatistics"
        },
        {
            "name": "useCrumbs",
            "baseName": "useCrumbs",
            "type": "boolean"
        },
        {
            "name": "useSecurity",
            "baseName": "useSecurity",
            "type": "boolean"
        },
        {
            "name": "views",
            "baseName": "views",
            "type": "Array<AllView>"
        }    ];

    static getAttributeTypeMap() {
        return Hudson.attributeTypeMap;
    }
}

export class HudsonMasterComputer {
    'class': string;
    'displayName': string;
    'executors': Array<HudsonMasterComputerexecutors>;
    'icon': string;
    'iconClassName': string;
    'idle': boolean;
    'jnlpAgent': boolean;
    'launchSupported': boolean;
    'loadStatistics': Label1;
    'manualLaunchAllowed': boolean;
    'monitorData': HudsonMasterComputermonitorData;
    'numExecutors': number;
    'offline': boolean;
    'offlineCause': string;
    'offlineCauseReason': string;
    'temporarilyOffline': boolean;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "executors",
            "baseName": "executors",
            "type": "Array<HudsonMasterComputerexecutors>"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "iconClassName",
            "baseName": "iconClassName",
            "type": "string"
        },
        {
            "name": "idle",
            "baseName": "idle",
            "type": "boolean"
        },
        {
            "name": "jnlpAgent",
            "baseName": "jnlpAgent",
            "type": "boolean"
        },
        {
            "name": "launchSupported",
            "baseName": "launchSupported",
            "type": "boolean"
        },
        {
            "name": "loadStatistics",
            "baseName": "loadStatistics",
            "type": "Label1"
        },
        {
            "name": "manualLaunchAllowed",
            "baseName": "manualLaunchAllowed",
            "type": "boolean"
        },
        {
            "name": "monitorData",
            "baseName": "monitorData",
            "type": "HudsonMasterComputermonitorData"
        },
        {
            "name": "numExecutors",
            "baseName": "numExecutors",
            "type": "number"
        },
        {
            "name": "offline",
            "baseName": "offline",
            "type": "boolean"
        },
        {
            "name": "offlineCause",
            "baseName": "offlineCause",
            "type": "string"
        },
        {
            "name": "offlineCauseReason",
            "baseName": "offlineCauseReason",
            "type": "string"
        },
        {
            "name": "temporarilyOffline",
            "baseName": "temporarilyOffline",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return HudsonMasterComputer.attributeTypeMap;
    }
}

export class HudsonMasterComputerexecutors {
    'currentExecutable': FreeStyleBuild;
    'idle': boolean;
    'likelyStuck': boolean;
    'number': number;
    'progress': number;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currentExecutable",
            "baseName": "currentExecutable",
            "type": "FreeStyleBuild"
        },
        {
            "name": "idle",
            "baseName": "idle",
            "type": "boolean"
        },
        {
            "name": "likelyStuck",
            "baseName": "likelyStuck",
            "type": "boolean"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "number"
        },
        {
            "name": "progress",
            "baseName": "progress",
            "type": "number"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HudsonMasterComputerexecutors.attributeTypeMap;
    }
}

export class HudsonMasterComputermonitorData {
    'hudsonNodeMonitorsSwapSpaceMonitor': SwapSpaceMonitorMemoryUsage2;
    'hudsonNodeMonitorsTemporarySpaceMonitor': DiskSpaceMonitorDescriptorDiskSpace;
    'hudsonNodeMonitorsDiskSpaceMonitor': DiskSpaceMonitorDescriptorDiskSpace;
    'hudsonNodeMonitorsArchitectureMonitor': string;
    'hudsonNodeMonitorsResponseTimeMonitor': ResponseTimeMonitorData;
    'hudsonNodeMonitorsClockMonitor': ClockDifference;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hudsonNodeMonitorsSwapSpaceMonitor",
            "baseName": "hudson.node_monitors.SwapSpaceMonitor",
            "type": "SwapSpaceMonitorMemoryUsage2"
        },
        {
            "name": "hudsonNodeMonitorsTemporarySpaceMonitor",
            "baseName": "hudson.node_monitors.TemporarySpaceMonitor",
            "type": "DiskSpaceMonitorDescriptorDiskSpace"
        },
        {
            "name": "hudsonNodeMonitorsDiskSpaceMonitor",
            "baseName": "hudson.node_monitors.DiskSpaceMonitor",
            "type": "DiskSpaceMonitorDescriptorDiskSpace"
        },
        {
            "name": "hudsonNodeMonitorsArchitectureMonitor",
            "baseName": "hudson.node_monitors.ArchitectureMonitor",
            "type": "string"
        },
        {
            "name": "hudsonNodeMonitorsResponseTimeMonitor",
            "baseName": "hudson.node_monitors.ResponseTimeMonitor",
            "type": "ResponseTimeMonitorData"
        },
        {
            "name": "hudsonNodeMonitorsClockMonitor",
            "baseName": "hudson.node_monitors.ClockMonitor",
            "type": "ClockDifference"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HudsonMasterComputermonitorData.attributeTypeMap;
    }
}

export class HudsonassignedLabels {
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HudsonassignedLabels.attributeTypeMap;
    }
}

export class InputStepImpl {
    'class': string;
    'links': InputStepImpllinks;
    'id': string;
    'message': string;
    'ok': string;
    'parameters': Array<StringParameterDefinition>;
    'submitter': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "InputStepImpllinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "ok",
            "baseName": "ok",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<StringParameterDefinition>"
        },
        {
            "name": "submitter",
            "baseName": "submitter",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InputStepImpl.attributeTypeMap;
    }
}

export class InputStepImpllinks {
    'self': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InputStepImpllinks.attributeTypeMap;
    }
}

export class Label1 {
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Label1.attributeTypeMap;
    }
}

export class Link {
    'class': string;
    'href': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Link.attributeTypeMap;
    }
}

export class ListView {
    'class': string;
    'description': string;
    'jobs': Array<FreeStyleProject>;
    'name': string;
    'url': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "jobs",
            "baseName": "jobs",
            "type": "Array<FreeStyleProject>"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ListView.attributeTypeMap;
    }
}

export class MultibranchPipeline {
    'displayName': string;
    'estimatedDurationInMillis': number;
    'latestRun': string;
    'name': string;
    'organization': string;
    'weatherScore': number;
    'branchNames': Array<string>;
    'numberOfFailingBranches': number;
    'numberOfFailingPullRequests': number;
    'numberOfSuccessfulBranches': number;
    'numberOfSuccessfulPullRequests': number;
    'totalNumberOfBranches': number;
    'totalNumberOfPullRequests': number;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "latestRun",
            "baseName": "latestRun",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "weatherScore",
            "baseName": "weatherScore",
            "type": "number"
        },
        {
            "name": "branchNames",
            "baseName": "branchNames",
            "type": "Array<string>"
        },
        {
            "name": "numberOfFailingBranches",
            "baseName": "numberOfFailingBranches",
            "type": "number"
        },
        {
            "name": "numberOfFailingPullRequests",
            "baseName": "numberOfFailingPullRequests",
            "type": "number"
        },
        {
            "name": "numberOfSuccessfulBranches",
            "baseName": "numberOfSuccessfulBranches",
            "type": "number"
        },
        {
            "name": "numberOfSuccessfulPullRequests",
            "baseName": "numberOfSuccessfulPullRequests",
            "type": "number"
        },
        {
            "name": "totalNumberOfBranches",
            "baseName": "totalNumberOfBranches",
            "type": "number"
        },
        {
            "name": "totalNumberOfPullRequests",
            "baseName": "totalNumberOfPullRequests",
            "type": "number"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MultibranchPipeline.attributeTypeMap;
    }
}

export class NullSCM {
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NullSCM.attributeTypeMap;
    }
}

export class Organisation {
    'class': string;
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Organisation.attributeTypeMap;
    }
}

export class Organisations extends Array<Organisation> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Organisations.attributeTypeMap);
    }
}

export class Pipeline {
    'class': string;
    'organization': string;
    'name': string;
    'displayName': string;
    'fullName': string;
    'weatherScore': number;
    'estimatedDurationInMillis': number;
    'latestRun': PipelinelatestRun;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "weatherScore",
            "baseName": "weatherScore",
            "type": "number"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "latestRun",
            "baseName": "latestRun",
            "type": "PipelinelatestRun"
        }    ];

    static getAttributeTypeMap() {
        return Pipeline.attributeTypeMap;
    }
}

export class PipelineActivities extends Array<PipelineActivity> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineActivities.attributeTypeMap);
    }
}

export class PipelineActivity {
    'class': string;
    'artifacts': Array<PipelineActivityartifacts>;
    'durationInMillis': number;
    'estimatedDurationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "artifacts",
            "baseName": "artifacts",
            "type": "Array<PipelineActivityartifacts>"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "enQueueTime",
            "baseName": "enQueueTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pipeline",
            "baseName": "pipeline",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "runSummary",
            "baseName": "runSummary",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commitId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineActivity.attributeTypeMap;
    }
}

export class PipelineActivityartifacts {
    'name': string;
    'size': number;
    'url': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineActivityartifacts.attributeTypeMap;
    }
}

export class PipelineBranches extends Array<PipelineBranchesitem> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineBranches.attributeTypeMap);
    }
}

export class PipelineBranchesitem {
    'displayName': string;
    'estimatedDurationInMillis': number;
    'name': string;
    'weatherScore': number;
    'latestRun': PipelineBranchesitemlatestRun;
    'organization': string;
    'pullRequest': PipelineBranchesitempullRequest;
    'totalNumberOfPullRequests': number;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "weatherScore",
            "baseName": "weatherScore",
            "type": "number"
        },
        {
            "name": "latestRun",
            "baseName": "latestRun",
            "type": "PipelineBranchesitemlatestRun"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pullRequest",
            "baseName": "pullRequest",
            "type": "PipelineBranchesitempullRequest"
        },
        {
            "name": "totalNumberOfPullRequests",
            "baseName": "totalNumberOfPullRequests",
            "type": "number"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineBranchesitem.attributeTypeMap;
    }
}

export class PipelineBranchesitemlatestRun {
    'durationInMillis': number;
    'estimatedDurationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "enQueueTime",
            "baseName": "enQueueTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pipeline",
            "baseName": "pipeline",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "runSummary",
            "baseName": "runSummary",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commitId",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineBranchesitemlatestRun.attributeTypeMap;
    }
}

export class PipelineBranchesitempullRequest {
    'links': PipelineBranchesitempullRequestlinks;
    'author': string;
    'id': string;
    'title': string;
    'url': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PipelineBranchesitempullRequestlinks"
        },
        {
            "name": "author",
            "baseName": "author",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineBranchesitempullRequest.attributeTypeMap;
    }
}

export class PipelineBranchesitempullRequestlinks {
    'self': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineBranchesitempullRequestlinks.attributeTypeMap;
    }
}

export class PipelineFolderImpl {
    'class': string;
    'displayName': string;
    'fullName': string;
    'name': string;
    'organization': string;
    'numberOfFolders': number;
    'numberOfPipelines': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "numberOfFolders",
            "baseName": "numberOfFolders",
            "type": "number"
        },
        {
            "name": "numberOfPipelines",
            "baseName": "numberOfPipelines",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PipelineFolderImpl.attributeTypeMap;
    }
}

export class PipelineImpl {
    'class': string;
    'displayName': string;
    'estimatedDurationInMillis': number;
    'fullName': string;
    'latestRun': string;
    'name': string;
    'organization': string;
    'weatherScore': number;
    'links': PipelineImpllinks;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "latestRun",
            "baseName": "latestRun",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "weatherScore",
            "baseName": "weatherScore",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "PipelineImpllinks"
        }    ];

    static getAttributeTypeMap() {
        return PipelineImpl.attributeTypeMap;
    }
}

export class PipelineImpllinks {
    'runs': Link;
    'self': Link;
    'queue': Link;
    'actions': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "runs",
            "baseName": "runs",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "queue",
            "baseName": "queue",
            "type": "Link"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineImpllinks.attributeTypeMap;
    }
}

export class PipelineQueue extends Array<QueueItemImpl> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineQueue.attributeTypeMap);
    }
}

export class PipelineRun {
    'class': string;
    'artifacts': Array<PipelineRunartifacts>;
    'durationInMillis': number;
    'estimatedDurationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "artifacts",
            "baseName": "artifacts",
            "type": "Array<PipelineRunartifacts>"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "enQueueTime",
            "baseName": "enQueueTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pipeline",
            "baseName": "pipeline",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "runSummary",
            "baseName": "runSummary",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commitId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineRun.attributeTypeMap;
    }
}

export class PipelineRunImpl {
    'class': string;
    'links': PipelineRunImpllinks;
    'durationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'estimatedDurationInMillis': number;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "PipelineRunImpllinks"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "enQueueTime",
            "baseName": "enQueueTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pipeline",
            "baseName": "pipeline",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "runSummary",
            "baseName": "runSummary",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commitId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineRunImpl.attributeTypeMap;
    }
}

export class PipelineRunImpllinks {
    'nodes': Link;
    'log': Link;
    'self': Link;
    'actions': Link;
    'steps': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nodes",
            "baseName": "nodes",
            "type": "Link"
        },
        {
            "name": "log",
            "baseName": "log",
            "type": "Link"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Link"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineRunImpllinks.attributeTypeMap;
    }
}

export class PipelineRunNode {
    'class': string;
    'displayName': string;
    'durationInMillis': number;
    'edges': Array<PipelineRunNodeedges>;
    'id': string;
    'result': string;
    'startTime': string;
    'state': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "edges",
            "baseName": "edges",
            "type": "Array<PipelineRunNodeedges>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineRunNode.attributeTypeMap;
    }
}

export class PipelineRunNodeSteps extends Array<PipelineStepImpl> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineRunNodeSteps.attributeTypeMap);
    }
}

export class PipelineRunNodeedges {
    'id': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineRunNodeedges.attributeTypeMap;
    }
}

export class PipelineRunNodes extends Array<PipelineRunNode> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineRunNodes.attributeTypeMap);
    }
}

export class PipelineRunSteps extends Array<GenericResource> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineRunSteps.attributeTypeMap);
    }
}

export class PipelineRunartifacts {
    'name': string;
    'size': number;
    'url': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineRunartifacts.attributeTypeMap;
    }
}

export class PipelineRuns extends Array<PipelineRun> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(PipelineRuns.attributeTypeMap);
    }
}

export class PipelineStepImpl {
    'class': string;
    'links': PipelineStepImpllinks;
    'displayName': string;
    'durationInMillis': number;
    'id': string;
    'input': InputStepImpl;
    'result': string;
    'startTime': string;
    'state': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "PipelineStepImpllinks"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "input",
            "baseName": "input",
            "type": "InputStepImpl"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineStepImpl.attributeTypeMap;
    }
}

export class PipelineStepImpllinks {
    'self': Link;
    'actions': Link;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Link"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Link"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelineStepImpllinks.attributeTypeMap;
    }
}

export class PipelinelatestRun {
    'artifacts': Array<PipelinelatestRunartifacts>;
    'durationInMillis': number;
    'estimatedDurationInMillis': number;
    'enQueueTime': string;
    'endTime': string;
    'id': string;
    'organization': string;
    'pipeline': string;
    'result': string;
    'runSummary': string;
    'startTime': string;
    'state': string;
    'type': string;
    'commitId': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "artifacts",
            "baseName": "artifacts",
            "type": "Array<PipelinelatestRunartifacts>"
        },
        {
            "name": "durationInMillis",
            "baseName": "durationInMillis",
            "type": "number"
        },
        {
            "name": "estimatedDurationInMillis",
            "baseName": "estimatedDurationInMillis",
            "type": "number"
        },
        {
            "name": "enQueueTime",
            "baseName": "enQueueTime",
            "type": "string"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        },
        {
            "name": "pipeline",
            "baseName": "pipeline",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        },
        {
            "name": "runSummary",
            "baseName": "runSummary",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "commitId",
            "baseName": "commitId",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelinelatestRun.attributeTypeMap;
    }
}

export class PipelinelatestRunartifacts {
    'name': string;
    'size': number;
    'url': string;
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PipelinelatestRunartifacts.attributeTypeMap;
    }
}

export class Pipelines extends Array<Pipeline> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Pipelines.attributeTypeMap);
    }
}

export class Queue {
    'class': string;
    'items': Array<QueueBlockedItem>;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "items",
            "baseName": "items",
            "type": "Array<QueueBlockedItem>"
        }    ];

    static getAttributeTypeMap() {
        return Queue.attributeTypeMap;
    }
}

export class QueueBlockedItem {
    'class': string;
    'actions': Array<CauseAction>;
    'blocked': boolean;
    'buildable': boolean;
    'id': number;
    'inQueueSince': number;
    'params': string;
    'stuck': boolean;
    'task': FreeStyleProject;
    'url': string;
    'why': string;
    'buildableStartMilliseconds': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<CauseAction>"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "boolean"
        },
        {
            "name": "buildable",
            "baseName": "buildable",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "inQueueSince",
            "baseName": "inQueueSince",
            "type": "number"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "string"
        },
        {
            "name": "stuck",
            "baseName": "stuck",
            "type": "boolean"
        },
        {
            "name": "task",
            "baseName": "task",
            "type": "FreeStyleProject"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "why",
            "baseName": "why",
            "type": "string"
        },
        {
            "name": "buildableStartMilliseconds",
            "baseName": "buildableStartMilliseconds",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return QueueBlockedItem.attributeTypeMap;
    }
}

export class QueueItemImpl {
    'class': string;
    'expectedBuildNumber': number;
    'id': string;
    'pipeline': string;
    'queuedTime': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "expectedBuildNumber",
            "baseName": "expectedBuildNumber",
            "type": "number"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "pipeline",
            "baseName": "pipeline",
            "type": "string"
        },
        {
            "name": "queuedTime",
            "baseName": "queuedTime",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return QueueItemImpl.attributeTypeMap;
    }
}

export class QueueLeftItem {
    'class': string;
    'actions': Array<CauseAction>;
    'blocked': boolean;
    'buildable': boolean;
    'id': number;
    'inQueueSince': number;
    'params': string;
    'stuck': boolean;
    'task': FreeStyleProject;
    'url': string;
    'why': string;
    'cancelled': boolean;
    'executable': FreeStyleBuild;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<CauseAction>"
        },
        {
            "name": "blocked",
            "baseName": "blocked",
            "type": "boolean"
        },
        {
            "name": "buildable",
            "baseName": "buildable",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "number"
        },
        {
            "name": "inQueueSince",
            "baseName": "inQueueSince",
            "type": "number"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "string"
        },
        {
            "name": "stuck",
            "baseName": "stuck",
            "type": "boolean"
        },
        {
            "name": "task",
            "baseName": "task",
            "type": "FreeStyleProject"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "why",
            "baseName": "why",
            "type": "string"
        },
        {
            "name": "cancelled",
            "baseName": "cancelled",
            "type": "boolean"
        },
        {
            "name": "executable",
            "baseName": "executable",
            "type": "FreeStyleBuild"
        }    ];

    static getAttributeTypeMap() {
        return QueueLeftItem.attributeTypeMap;
    }
}

export class ResponseTimeMonitorData {
    'class': string;
    'timestamp': number;
    'average': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "timestamp",
            "baseName": "timestamp",
            "type": "number"
        },
        {
            "name": "average",
            "baseName": "average",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ResponseTimeMonitorData.attributeTypeMap;
    }
}

export class ScmOrganisations extends Array<GithubOrganization> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(ScmOrganisations.attributeTypeMap);
    }
}

export class StringParameterDefinition {
    'class': string;
    'defaultParameterValue': StringParameterValue;
    'description': string;
    'name': string;
    'type': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "defaultParameterValue",
            "baseName": "defaultParameterValue",
            "type": "StringParameterValue"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StringParameterDefinition.attributeTypeMap;
    }
}

export class StringParameterValue {
    'class': string;
    'name': string;
    'value': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StringParameterValue.attributeTypeMap;
    }
}

export class SwapSpaceMonitorMemoryUsage2 {
    'class': string;
    'availablePhysicalMemory': number;
    'availableSwapSpace': number;
    'totalPhysicalMemory': number;
    'totalSwapSpace': number;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "availablePhysicalMemory",
            "baseName": "availablePhysicalMemory",
            "type": "number"
        },
        {
            "name": "availableSwapSpace",
            "baseName": "availableSwapSpace",
            "type": "number"
        },
        {
            "name": "totalPhysicalMemory",
            "baseName": "totalPhysicalMemory",
            "type": "number"
        },
        {
            "name": "totalSwapSpace",
            "baseName": "totalSwapSpace",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return SwapSpaceMonitorMemoryUsage2.attributeTypeMap;
    }
}

export class UnlabeledLoadStatistics {
    'class': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UnlabeledLoadStatistics.attributeTypeMap;
    }
}

export class User {
    'class': string;
    'id': string;
    'fullName': string;
    'email': string;
    'name': string;

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "class",
            "baseName": "_class",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fullName",
            "baseName": "fullName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return User.attributeTypeMap;
    }
}

export class UserFavorites extends Array<FavoriteImpl> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(UserFavorites.attributeTypeMap);
    }
}

export class Users extends Array<User> {

    static discriminator = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
    ];

    static getAttributeTypeMap() {
        return super.getAttributeTypeMap().concat(Users.attributeTypeMap);
    }
}


let enumsMap = {
}

let typeMap = {
    "AllView": AllView,
    "Body": Body,
    "BranchImpl": BranchImpl,
    "BranchImpllinks": BranchImpllinks,
    "BranchImplpermissions": BranchImplpermissions,
    "CauseAction": CauseAction,
    "CauseUserIdCause": CauseUserIdCause,
    "ClassesByClass": ClassesByClass,
    "ClockDifference": ClockDifference,
    "ComputerSet": ComputerSet,
    "DefaultCrumbIssuer": DefaultCrumbIssuer,
    "DiskSpaceMonitorDescriptorDiskSpace": DiskSpaceMonitorDescriptorDiskSpace,
    "EmptyChangeLogSet": EmptyChangeLogSet,
    "ExtensionClassContainerImpl1": ExtensionClassContainerImpl1,
    "ExtensionClassContainerImpl1links": ExtensionClassContainerImpl1links,
    "ExtensionClassContainerImpl1map": ExtensionClassContainerImpl1map,
    "ExtensionClassImpl": ExtensionClassImpl,
    "ExtensionClassImpllinks": ExtensionClassImpllinks,
    "FavoriteImpl": FavoriteImpl,
    "FavoriteImpllinks": FavoriteImpllinks,
    "FreeStyleBuild": FreeStyleBuild,
    "FreeStyleProject": FreeStyleProject,
    "FreeStyleProjectactions": FreeStyleProjectactions,
    "FreeStyleProjecthealthReport": FreeStyleProjecthealthReport,
    "GenericResource": GenericResource,
    "GithubContent": GithubContent,
    "GithubFile": GithubFile,
    "GithubOrganization": GithubOrganization,
    "GithubOrganizationlinks": GithubOrganizationlinks,
    "GithubRepositories": GithubRepositories,
    "GithubRepositorieslinks": GithubRepositorieslinks,
    "GithubRepository": GithubRepository,
    "GithubRepositorylinks": GithubRepositorylinks,
    "GithubRepositorypermissions": GithubRepositorypermissions,
    "GithubRespositoryContainer": GithubRespositoryContainer,
    "GithubRespositoryContainerlinks": GithubRespositoryContainerlinks,
    "GithubScm": GithubScm,
    "GithubScmlinks": GithubScmlinks,
    "Hudson": Hudson,
    "HudsonMasterComputer": HudsonMasterComputer,
    "HudsonMasterComputerexecutors": HudsonMasterComputerexecutors,
    "HudsonMasterComputermonitorData": HudsonMasterComputermonitorData,
    "HudsonassignedLabels": HudsonassignedLabels,
    "InputStepImpl": InputStepImpl,
    "InputStepImpllinks": InputStepImpllinks,
    "Label1": Label1,
    "Link": Link,
    "ListView": ListView,
    "MultibranchPipeline": MultibranchPipeline,
    "NullSCM": NullSCM,
    "Organisation": Organisation,
    "Organisations": Organisations,
    "Pipeline": Pipeline,
    "PipelineActivities": PipelineActivities,
    "PipelineActivity": PipelineActivity,
    "PipelineActivityartifacts": PipelineActivityartifacts,
    "PipelineBranches": PipelineBranches,
    "PipelineBranchesitem": PipelineBranchesitem,
    "PipelineBranchesitemlatestRun": PipelineBranchesitemlatestRun,
    "PipelineBranchesitempullRequest": PipelineBranchesitempullRequest,
    "PipelineBranchesitempullRequestlinks": PipelineBranchesitempullRequestlinks,
    "PipelineFolderImpl": PipelineFolderImpl,
    "PipelineImpl": PipelineImpl,
    "PipelineImpllinks": PipelineImpllinks,
    "PipelineQueue": PipelineQueue,
    "PipelineRun": PipelineRun,
    "PipelineRunImpl": PipelineRunImpl,
    "PipelineRunImpllinks": PipelineRunImpllinks,
    "PipelineRunNode": PipelineRunNode,
    "PipelineRunNodeSteps": PipelineRunNodeSteps,
    "PipelineRunNodeedges": PipelineRunNodeedges,
    "PipelineRunNodes": PipelineRunNodes,
    "PipelineRunSteps": PipelineRunSteps,
    "PipelineRunartifacts": PipelineRunartifacts,
    "PipelineRuns": PipelineRuns,
    "PipelineStepImpl": PipelineStepImpl,
    "PipelineStepImpllinks": PipelineStepImpllinks,
    "PipelinelatestRun": PipelinelatestRun,
    "PipelinelatestRunartifacts": PipelinelatestRunartifacts,
    "Pipelines": Pipelines,
    "Queue": Queue,
    "QueueBlockedItem": QueueBlockedItem,
    "QueueItemImpl": QueueItemImpl,
    "QueueLeftItem": QueueLeftItem,
    "ResponseTimeMonitorData": ResponseTimeMonitorData,
    "ScmOrganisations": ScmOrganisations,
    "StringParameterDefinition": StringParameterDefinition,
    "StringParameterValue": StringParameterValue,
    "SwapSpaceMonitorMemoryUsage2": SwapSpaceMonitorMemoryUsage2,
    "UnlabeledLoadStatistics": UnlabeledLoadStatistics,
    "User": User,
    "UserFavorites": UserFavorites,
    "Users": Users,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum BlueOceanApiApiKeys {
}

export class BlueOceanApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jenkins_auth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BlueOceanApiApiKeys, value: string) {
        this.authentications[BlueOceanApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.jenkins_auth.username = username;
    }

    set password(password: string) {
        this.authentications.jenkins_auth.password = password;
    }
    /**
     * Delete queue item from an organization pipeline queue
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     */
    public deletePipelineQueueItem (organization: string, pipeline: string, queue: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'queue' + '}', String(queue));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling deletePipelineQueueItem.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling deletePipelineQueueItem.');
        }

        // verify required parameter 'queue' is not null or undefined
        if (queue === null || queue === undefined) {
            throw new Error('Required parameter queue was null or undefined when calling deletePipelineQueueItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'DELETE',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve authenticated user details for an organization
     * @param organization Name of the organization
     */
    public getAuthenticatedUser (organization: string) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/user/'
            .replace('{' + 'organization' + '}', String(organization));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getAuthenticatedUser.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    public getClasses (_class: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/classes/{class}'
            .replace('{' + 'class' + '}', String(_class));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter '_class' is not null or undefined
        if (_class === null || _class === undefined) {
            throw new Error('Required parameter _class was null or undefined when calling getClasses.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve organization details
     * @param organization Name of the organization
     */
    public getOrganisation (organization: string) : Promise<{ response: http.ClientResponse; body: Organisation;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}'
            .replace('{' + 'organization' + '}', String(organization));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getOrganisation.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Organisation;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organisation");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all organizations details
     */
    public getOrganisations () : Promise<{ response: http.ClientResponse; body: Organisations;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Organisations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Organisations");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve pipeline details for an organization
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    public getPipeline (organization: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: Pipeline;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipeline.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipeline.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipeline;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipeline");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all activities details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    public getPipelineActivities (organization: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: PipelineActivities;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineActivities.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineActivities.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineActivities;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineActivities");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve branch details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    public getPipelineBranch (organization: string, pipeline: string, branch: string) : Promise<{ response: http.ClientResponse; body: BranchImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'branch' + '}', String(branch));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineBranch.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranch.');
        }

        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling getPipelineBranch.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: BranchImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "BranchImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve branch run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     */
    public getPipelineBranchRun (organization: string, pipeline: string, branch: string, run: string) : Promise<{ response: http.ClientResponse; body: PipelineRun;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'branch' + '}', String(branch))
            .replace('{' + 'run' + '}', String(run));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineBranchRun.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranchRun.');
        }

        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling getPipelineBranchRun.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineBranchRun.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRun;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRun");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all branches details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    public getPipelineBranches (organization: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: MultibranchPipeline;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineBranches.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranches.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: MultibranchPipeline;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MultibranchPipeline");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve pipeline folder for an organization
     * @param organization Name of the organization
     * @param folder Name of the folder
     */
    public getPipelineFolder (organization: string, folder: string) : Promise<{ response: http.ClientResponse; body: PipelineFolderImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{folder}/'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'folder' + '}', String(folder));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineFolder.');
        }

        // verify required parameter 'folder' is not null or undefined
        if (folder === null || folder === undefined) {
            throw new Error('Required parameter folder was null or undefined when calling getPipelineFolder.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineFolderImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineFolderImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve pipeline details for an organization folder
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    public getPipelineFolderPipeline (organization: string, pipeline: string, folder: string) : Promise<{ response: http.ClientResponse; body: PipelineImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'folder' + '}', String(folder));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineFolderPipeline.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineFolderPipeline.');
        }

        // verify required parameter 'folder' is not null or undefined
        if (folder === null || folder === undefined) {
            throw new Error('Required parameter folder was null or undefined when calling getPipelineFolderPipeline.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve queue details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    public getPipelineQueue (organization: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: PipelineQueue;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineQueue.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineQueue.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineQueue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineQueue");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    public getPipelineRun (organization: string, pipeline: string, run: string) : Promise<{ response: http.ClientResponse; body: PipelineRun;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRun.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRun.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRun.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRun;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRun");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get log for a pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body
     */
    public getPipelineRunLog (organization: string, pipeline: string, run: string, start?: number, download?: boolean) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRunLog.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRunLog.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRunLog.');
        }

        if (start !== undefined) {
            queryParameters['start'] = ObjectSerializer.serialize(start, "number");
        }

        if (download !== undefined) {
            queryParameters['download'] = ObjectSerializer.serialize(download, "boolean");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    public getPipelineRunNode (organization: string, pipeline: string, run: string, node: string) : Promise<{ response: http.ClientResponse; body: PipelineRunNode;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run))
            .replace('{' + 'node' + '}', String(node));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRunNode.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRunNode.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRunNode.');
        }

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getPipelineRunNode.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRunNode;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRunNode");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    public getPipelineRunNodeStep (organization: string, pipeline: string, run: string, node: string, step: string) : Promise<{ response: http.ClientResponse; body: PipelineStepImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run))
            .replace('{' + 'node' + '}', String(node))
            .replace('{' + 'step' + '}', String(step));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRunNodeStep.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRunNodeStep.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRunNodeStep.');
        }

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getPipelineRunNodeStep.');
        }

        // verify required parameter 'step' is not null or undefined
        if (step === null || step === undefined) {
            throw new Error('Required parameter step was null or undefined when calling getPipelineRunNodeStep.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineStepImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineStepImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get log for a pipeline run node step
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    public getPipelineRunNodeStepLog (organization: string, pipeline: string, run: string, node: string, step: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run))
            .replace('{' + 'node' + '}', String(node))
            .replace('{' + 'step' + '}', String(step));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRunNodeStepLog.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRunNodeStepLog.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRunNodeStepLog.');
        }

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getPipelineRunNodeStepLog.');
        }

        // verify required parameter 'step' is not null or undefined
        if (step === null || step === undefined) {
            throw new Error('Required parameter step was null or undefined when calling getPipelineRunNodeStepLog.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve run node steps details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    public getPipelineRunNodeSteps (organization: string, pipeline: string, run: string, node: string) : Promise<{ response: http.ClientResponse; body: PipelineRunNodeSteps;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run))
            .replace('{' + 'node' + '}', String(node));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRunNodeSteps.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRunNodeSteps.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRunNodeSteps.');
        }

        // verify required parameter 'node' is not null or undefined
        if (node === null || node === undefined) {
            throw new Error('Required parameter node was null or undefined when calling getPipelineRunNodeSteps.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRunNodeSteps;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRunNodeSteps");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve run nodes details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    public getPipelineRunNodes (organization: string, pipeline: string, run: string) : Promise<{ response: http.ClientResponse; body: PipelineRunNodes;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRunNodes.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRunNodes.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling getPipelineRunNodes.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRunNodes;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRunNodes");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all runs details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    public getPipelineRuns (organization: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: PipelineRuns;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelineRuns.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineRuns.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRuns;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRuns");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve all pipelines details for an organization
     * @param organization Name of the organization
     */
    public getPipelines (organization: string) : Promise<{ response: http.ClientResponse; body: Pipelines;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/'
            .replace('{' + 'organization' + '}', String(organization));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getPipelines.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Pipelines;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Pipelines");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve SCM details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     */
    public getSCM (organization: string, scm: string) : Promise<{ response: http.ClientResponse; body: GithubScm;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/scm/{scm}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'scm' + '}', String(scm));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getSCM.');
        }

        // verify required parameter 'scm' is not null or undefined
        if (scm === null || scm === undefined) {
            throw new Error('Required parameter scm was null or undefined when calling getSCM.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GithubScm;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GithubScm");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve SCM organization repositories details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID
     * @param pageSize Number of items in a page
     * @param pageNumber Page number
     */
    public getSCMOrganisationRepositories (organization: string, scm: string, scmOrganisation: string, credentialId?: string, pageSize?: number, pageNumber?: number) : Promise<{ response: http.ClientResponse; body: ScmOrganisations;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'scm' + '}', String(scm))
            .replace('{' + 'scmOrganisation' + '}', String(scmOrganisation));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getSCMOrganisationRepositories.');
        }

        // verify required parameter 'scm' is not null or undefined
        if (scm === null || scm === undefined) {
            throw new Error('Required parameter scm was null or undefined when calling getSCMOrganisationRepositories.');
        }

        // verify required parameter 'scmOrganisation' is not null or undefined
        if (scmOrganisation === null || scmOrganisation === undefined) {
            throw new Error('Required parameter scmOrganisation was null or undefined when calling getSCMOrganisationRepositories.');
        }

        if (credentialId !== undefined) {
            queryParameters['credentialId'] = ObjectSerializer.serialize(credentialId, "string");
        }

        if (pageSize !== undefined) {
            queryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (pageNumber !== undefined) {
            queryParameters['pageNumber'] = ObjectSerializer.serialize(pageNumber, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScmOrganisations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ScmOrganisations");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve SCM organization repository details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID
     */
    public getSCMOrganisationRepository (organization: string, scm: string, scmOrganisation: string, repository: string, credentialId?: string) : Promise<{ response: http.ClientResponse; body: ScmOrganisations;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'scm' + '}', String(scm))
            .replace('{' + 'scmOrganisation' + '}', String(scmOrganisation))
            .replace('{' + 'repository' + '}', String(repository));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getSCMOrganisationRepository.');
        }

        // verify required parameter 'scm' is not null or undefined
        if (scm === null || scm === undefined) {
            throw new Error('Required parameter scm was null or undefined when calling getSCMOrganisationRepository.');
        }

        // verify required parameter 'scmOrganisation' is not null or undefined
        if (scmOrganisation === null || scmOrganisation === undefined) {
            throw new Error('Required parameter scmOrganisation was null or undefined when calling getSCMOrganisationRepository.');
        }

        // verify required parameter 'repository' is not null or undefined
        if (repository === null || repository === undefined) {
            throw new Error('Required parameter repository was null or undefined when calling getSCMOrganisationRepository.');
        }

        if (credentialId !== undefined) {
            queryParameters['credentialId'] = ObjectSerializer.serialize(credentialId, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScmOrganisations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ScmOrganisations");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve SCM organizations details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID
     */
    public getSCMOrganisations (organization: string, scm: string, credentialId?: string) : Promise<{ response: http.ClientResponse; body: ScmOrganisations;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/scm/{scm}/organizations'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'scm' + '}', String(scm));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getSCMOrganisations.');
        }

        // verify required parameter 'scm' is not null or undefined
        if (scm === null || scm === undefined) {
            throw new Error('Required parameter scm was null or undefined when calling getSCMOrganisations.');
        }

        if (credentialId !== undefined) {
            queryParameters['credentialId'] = ObjectSerializer.serialize(credentialId, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ScmOrganisations;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ScmOrganisations");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve user details for an organization
     * @param organization Name of the organization
     * @param user Name of the user
     */
    public getUser (organization: string, user: string) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/users/{user}'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'user' + '}', String(user));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getUser.');
        }

        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUser.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve user favorites details for an organization
     * @param user Name of the user
     */
    public getUserFavorites (user: string) : Promise<{ response: http.ClientResponse; body: UserFavorites;  }> {
        const localVarPath = this.basePath + '/blue/rest/users/{user}/favorites'
            .replace('{' + 'user' + '}', String(user));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUserFavorites.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UserFavorites;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserFavorites");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve users details for an organization
     * @param organization Name of the organization
     */
    public getUsers (organization: string) : Promise<{ response: http.ClientResponse; body: User;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/users/'
            .replace('{' + 'organization' + '}', String(organization));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling getUsers.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: User;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "User");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Replay an organization pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    public postPipelineRun (organization: string, pipeline: string, run: string) : Promise<{ response: http.ClientResponse; body: QueueItemImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling postPipelineRun.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling postPipelineRun.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling postPipelineRun.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QueueItemImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QueueItemImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Start a build for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    public postPipelineRuns (organization: string, pipeline: string) : Promise<{ response: http.ClientResponse; body: QueueItemImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling postPipelineRuns.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling postPipelineRuns.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: QueueItemImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QueueItemImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Favorite/unfavorite a pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     */
    public putPipelineFavorite (organization: string, pipeline: string, body: Body) : Promise<{ response: http.ClientResponse; body: FavoriteImpl;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling putPipelineFavorite.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling putPipelineFavorite.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putPipelineFavorite.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FavoriteImpl;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FavoriteImpl");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Stop a build of an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds
     */
    public putPipelineRun (organization: string, pipeline: string, run: string, blocking?: string, timeOutInSecs?: number) : Promise<{ response: http.ClientResponse; body: PipelineRun;  }> {
        const localVarPath = this.basePath + '/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop'
            .replace('{' + 'organization' + '}', String(organization))
            .replace('{' + 'pipeline' + '}', String(pipeline))
            .replace('{' + 'run' + '}', String(run));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'organization' is not null or undefined
        if (organization === null || organization === undefined) {
            throw new Error('Required parameter organization was null or undefined when calling putPipelineRun.');
        }

        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling putPipelineRun.');
        }

        // verify required parameter 'run' is not null or undefined
        if (run === null || run === undefined) {
            throw new Error('Required parameter run was null or undefined when calling putPipelineRun.');
        }

        if (blocking !== undefined) {
            queryParameters['blocking'] = ObjectSerializer.serialize(blocking, "string");
        }

        if (timeOutInSecs !== undefined) {
            queryParameters['timeOutInSecs'] = ObjectSerializer.serialize(timeOutInSecs, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'PUT',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PipelineRun;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PipelineRun");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Search for any resource details
     * @param q Query string
     */
    public search (q: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/search/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling search.');
        }

        if (q !== undefined) {
            queryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get classes details
     * @param q Query string containing an array of class names
     */
    public searchClasses (q: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/blue/rest/classes/';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling searchClasses.');
        }

        if (q !== undefined) {
            queryParameters['q'] = ObjectSerializer.serialize(q, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RemoteAccessApiApiKeys {
}

export class RemoteAccessApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'jenkins_auth': new HttpBasicAuth(),
    }

    constructor(basePath?: string);
    constructor(username: string, password: string, basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            this.username = basePathOrUsername;
            this.password = password
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RemoteAccessApiApiKeys, value: string) {
        this.authentications[RemoteAccessApiApiKeys[key]].apiKey = value;
    }
    set username(username: string) {
        this.authentications.jenkins_auth.username = username;
    }

    set password(password: string) {
        this.authentications.jenkins_auth.password = password;
    }
    /**
     * Retrieve computer details
     * @param depth Recursion depth in response model
     */
    public getComputer (depth: number) : Promise<{ response: http.ClientResponse; body: ComputerSet;  }> {
        const localVarPath = this.basePath + '/computer/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'depth' is not null or undefined
        if (depth === null || depth === undefined) {
            throw new Error('Required parameter depth was null or undefined when calling getComputer.');
        }

        if (depth !== undefined) {
            queryParameters['depth'] = ObjectSerializer.serialize(depth, "number");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ComputerSet;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ComputerSet");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve CSRF protection token
     */
    public getCrumb () : Promise<{ response: http.ClientResponse; body: DefaultCrumbIssuer;  }> {
        const localVarPath = this.basePath + '/crumbIssuer/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DefaultCrumbIssuer;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DefaultCrumbIssuer");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Jenkins details
     */
    public getJenkins () : Promise<{ response: http.ClientResponse; body: Hudson;  }> {
        const localVarPath = this.basePath + '/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Hudson;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Hudson");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve job details
     * @param name Name of the job
     */
    public getJob (name: string) : Promise<{ response: http.ClientResponse; body: FreeStyleProject;  }> {
        const localVarPath = this.basePath + '/job/{name}/api/json'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJob.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FreeStyleProject;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FreeStyleProject");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve job configuration
     * @param name Name of the job
     */
    public getJobConfig (name: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/job/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJobConfig.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve job's last build details
     * @param name Name of the job
     */
    public getJobLastBuild (name: string) : Promise<{ response: http.ClientResponse; body: FreeStyleBuild;  }> {
        const localVarPath = this.basePath + '/job/{name}/lastBuild/api/json'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJobLastBuild.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: FreeStyleBuild;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FreeStyleBuild");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve job's build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    public getJobProgressiveText (name: string, number: string, start: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/{number}/logText/progressiveText'
            .replace('{' + 'name' + '}', String(name))
            .replace('{' + 'number' + '}', String(number));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getJobProgressiveText.');
        }

        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getJobProgressiveText.');
        }

        // verify required parameter 'start' is not null or undefined
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getJobProgressiveText.');
        }

        if (start !== undefined) {
            queryParameters['start'] = ObjectSerializer.serialize(start, "string");
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve queue details
     */
    public getQueue () : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + '/queue/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Queue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Queue");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve queued item details
     * @param number Queue number
     */
    public getQueueItem (number: string) : Promise<{ response: http.ClientResponse; body: Queue;  }> {
        const localVarPath = this.basePath + '/queue/item/{number}/api/json'
            .replace('{' + 'number' + '}', String(number));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'number' is not null or undefined
        if (number === null || number === undefined) {
            throw new Error('Required parameter number was null or undefined when calling getQueueItem.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Queue;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Queue");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve view details
     * @param name Name of the view
     */
    public getView (name: string) : Promise<{ response: http.ClientResponse; body: ListView;  }> {
        const localVarPath = this.basePath + '/view/{name}/api/json'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getView.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ListView;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ListView");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve view configuration
     * @param name Name of the view
     */
    public getViewConfig (name: string) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/view/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getViewConfig.');
        }


        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Jenkins headers
     */
    public headJenkins () : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/api/json';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};



        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'HEAD',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    public postCreateItem (name: string, from?: string, mode?: string, body?: string, jenkinsCrumb?: string, contentType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/createItem';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postCreateItem.');
        }

        if (name !== undefined) {
            queryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        if (from !== undefined) {
            queryParameters['from'] = ObjectSerializer.serialize(from, "string");
        }

        if (mode !== undefined) {
            queryParameters['mode'] = ObjectSerializer.serialize(mode, "string");
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");
        headerParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    public postCreateView (name: string, body?: string, jenkinsCrumb?: string, contentType?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/createView';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postCreateView.');
        }

        if (name !== undefined) {
            queryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");
        headerParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobBuild (name: string, json: string, token?: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/build'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobBuild.');
        }

        // verify required parameter 'json' is not null or undefined
        if (json === null || json === undefined) {
            throw new Error('Required parameter json was null or undefined when calling postJobBuild.');
        }

        if (json !== undefined) {
            queryParameters['json'] = ObjectSerializer.serialize(json, "string");
        }

        if (token !== undefined) {
            queryParameters['token'] = ObjectSerializer.serialize(token, "string");
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobConfig (name: string, body: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobConfig.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postJobConfig.');
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobDelete (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/doDelete'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobDelete.');
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobDisable (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/disable'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobDisable.');
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobEnable (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/enable'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobEnable.');
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    public postJobLastBuildStop (name: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/job/{name}/lastBuild/stop'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postJobLastBuildStop.');
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    public postViewConfig (name: string, body: string, jenkinsCrumb?: string) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/view/{name}/config.xml'
            .replace('{' + 'name' + '}', String(name));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling postViewConfig.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postViewConfig.');
        }

        headerParams['Jenkins-Crumb'] = ObjectSerializer.serialize(jenkinsCrumb, "string");

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'POST',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.jenkins_auth.applyToRequest(requestOptions);

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
