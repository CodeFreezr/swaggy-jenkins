/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator 2.3.0-SNAPSHOT.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */



#include "GithubRepositories.h"

namespace io {
namespace swagger {
namespace client {
namespace model {

GithubRepositories::GithubRepositories()
{
    m__class = U("");
    m__classIsSet = false;
    m__linksIsSet = false;
    m_ItemsIsSet = false;
    m_LastPage = 0;
    m_LastPageIsSet = false;
    m_NextPage = 0;
    m_NextPageIsSet = false;
    m_PageSize = 0;
    m_PageSizeIsSet = false;
}

GithubRepositories::~GithubRepositories()
{
}

void GithubRepositories::validate()
{
    // TODO: implement validation
}

web::json::value GithubRepositories::toJson() const
{
    web::json::value val = web::json::value::object();

    if(m__classIsSet)
    {
        val[U("_class")] = ModelBase::toJson(m__class);
    }
    if(m__linksIsSet)
    {
        val[U("_links")] = ModelBase::toJson(m__links);
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Items )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        if(jsonArray.size() > 0)
        {
            val[U("items")] = web::json::value::array(jsonArray);
        }
    }
    if(m_LastPageIsSet)
    {
        val[U("lastPage")] = ModelBase::toJson(m_LastPage);
    }
    if(m_NextPageIsSet)
    {
        val[U("nextPage")] = ModelBase::toJson(m_NextPage);
    }
    if(m_PageSizeIsSet)
    {
        val[U("pageSize")] = ModelBase::toJson(m_PageSize);
    }

    return val;
}

void GithubRepositories::fromJson(web::json::value& val)
{
    if(val.has_field(U("_class")))
    {
        setClass(ModelBase::stringFromJson(val[U("_class")]));
    }
    if(val.has_field(U("_links")))
    {
        if(!val[U("_links")].is_null())
        {
            std::shared_ptr<GithubRepositorieslinks> newItem(new GithubRepositorieslinks());
            newItem->fromJson(val[U("_links")]);
            setLinks( newItem );
        }
    }
    {
        m_Items.clear();
        std::vector<web::json::value> jsonArray;
        if(val.has_field(U("items")))
        {
        for( auto& item : val[U("items")].as_array() )
        {
            if(item.is_null())
            {
                m_Items.push_back( std::shared_ptr<GithubRepository>(nullptr) );
            }
            else
            {
                std::shared_ptr<GithubRepository> newItem(new GithubRepository());
                newItem->fromJson(item);
                m_Items.push_back( newItem );
            }
        }
        }
    }
    if(val.has_field(U("lastPage")))
    {
        setLastPage(ModelBase::int32_tFromJson(val[U("lastPage")]));
    }
    if(val.has_field(U("nextPage")))
    {
        setNextPage(ModelBase::int32_tFromJson(val[U("nextPage")]));
    }
    if(val.has_field(U("pageSize")))
    {
        setPageSize(ModelBase::int32_tFromJson(val[U("pageSize")]));
    }
}

void GithubRepositories::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(m__classIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("_class"), m__class));
        
    }
    if(m__linksIsSet)
    {
        if (m__links.get())
        {
            m__links->toMultipart(multipart, U("_links."));
        }
        
    }
    {
        std::vector<web::json::value> jsonArray;
        for( auto& item : m_Items )
        {
            jsonArray.push_back(ModelBase::toJson(item));
        }
        
        if(jsonArray.size() > 0)
        {
            multipart->add(ModelBase::toHttpContent(namePrefix + U("items"), web::json::value::array(jsonArray), U("application/json")));
        }
    }
    if(m_LastPageIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("lastPage"), m_LastPage));
    }
    if(m_NextPageIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("nextPage"), m_NextPage));
    }
    if(m_PageSizeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + U("pageSize"), m_PageSize));
    }
}

void GithubRepositories::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix[namePrefix.size() - 1] != U('.'))
    {
        namePrefix += U(".");
    }

    if(multipart->hasContent(U("_class")))
    {
        setClass(ModelBase::stringFromHttpContent(multipart->getContent(U("_class"))));
    }
    if(multipart->hasContent(U("_links")))
    {
        if(multipart->hasContent(U("_links")))
        {
            std::shared_ptr<GithubRepositorieslinks> newItem(new GithubRepositorieslinks());
            newItem->fromMultiPart(multipart, U("_links."));
            setLinks( newItem );
        }
    }
    {
        m_Items.clear();
        if(multipart->hasContent(U("items")))
        {

        web::json::value jsonArray = web::json::value::parse(ModelBase::stringFromHttpContent(multipart->getContent(U("items"))));
        for( auto& item : jsonArray.as_array() )
        {
            if(item.is_null())
            {
                m_Items.push_back( std::shared_ptr<GithubRepository>(nullptr) );
            }
            else
            {
                std::shared_ptr<GithubRepository> newItem(new GithubRepository());
                newItem->fromJson(item);
                m_Items.push_back( newItem );
            }
        }
        }
    }
    if(multipart->hasContent(U("lastPage")))
    {
        setLastPage(ModelBase::int32_tFromHttpContent(multipart->getContent(U("lastPage"))));
    }
    if(multipart->hasContent(U("nextPage")))
    {
        setNextPage(ModelBase::int32_tFromHttpContent(multipart->getContent(U("nextPage"))));
    }
    if(multipart->hasContent(U("pageSize")))
    {
        setPageSize(ModelBase::int32_tFromHttpContent(multipart->getContent(U("pageSize"))));
    }
}

utility::string_t GithubRepositories::getClass() const
{
    return m__class;
}


void GithubRepositories::setClass(utility::string_t value)
{
    m__class = value;
    m__classIsSet = true;
}
bool GithubRepositories::classIsSet() const
{
    return m__classIsSet;
}

void GithubRepositories::unset_class()
{
    m__classIsSet = false;
}

std::shared_ptr<GithubRepositorieslinks> GithubRepositories::getLinks() const
{
    return m__links;
}


void GithubRepositories::setLinks(std::shared_ptr<GithubRepositorieslinks> value)
{
    m__links = value;
    m__linksIsSet = true;
}
bool GithubRepositories::linksIsSet() const
{
    return m__linksIsSet;
}

void GithubRepositories::unset_links()
{
    m__linksIsSet = false;
}

std::vector<std::shared_ptr<GithubRepository>>& GithubRepositories::getItems()
{
    return m_Items;
}

void GithubRepositories::setItems(std::vector<std::shared_ptr<GithubRepository>> value)
{
    m_Items = value;
    m_ItemsIsSet = true;
}
bool GithubRepositories::itemsIsSet() const
{
    return m_ItemsIsSet;
}

void GithubRepositories::unsetItems()
{
    m_ItemsIsSet = false;
}

int32_t GithubRepositories::getLastPage() const
{
    return m_LastPage;
}


void GithubRepositories::setLastPage(int32_t value)
{
    m_LastPage = value;
    m_LastPageIsSet = true;
}
bool GithubRepositories::lastPageIsSet() const
{
    return m_LastPageIsSet;
}

void GithubRepositories::unsetLastPage()
{
    m_LastPageIsSet = false;
}

int32_t GithubRepositories::getNextPage() const
{
    return m_NextPage;
}


void GithubRepositories::setNextPage(int32_t value)
{
    m_NextPage = value;
    m_NextPageIsSet = true;
}
bool GithubRepositories::nextPageIsSet() const
{
    return m_NextPageIsSet;
}

void GithubRepositories::unsetNextPage()
{
    m_NextPageIsSet = false;
}

int32_t GithubRepositories::getPageSize() const
{
    return m_PageSize;
}


void GithubRepositories::setPageSize(int32_t value)
{
    m_PageSize = value;
    m_PageSizeIsSet = true;
}
bool GithubRepositories::pageSizeIsSet() const
{
    return m_PageSizeIsSet;
}

void GithubRepositories::unsetPageSize()
{
    m_PageSizeIsSet = false;
}

}
}
}
}

