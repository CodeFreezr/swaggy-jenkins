/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface GetClassesByClass {
    "classes"?: Array<string>;
    "class"?: string;
}

export interface GetMultibranchPipeline {
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "latestRun"?: string;
    "name"?: string;
    "organization"?: string;
    "weatherScore"?: number;
    "branchNames"?: Array<string>;
    "numberOfFailingBranches"?: number;
    "numberOfFailingPullRequests"?: number;
    "numberOfSuccessfulBranches"?: number;
    "numberOfSuccessfulPullRequests"?: number;
    "totalNumberOfBranches"?: number;
    "totalNumberOfPullRequests"?: number;
    "class"?: string;
}

export interface GetOrganisations extends Array<SwaggyjenkinsOrganisation> {
}

export interface GetPipelineBranches extends Array<GetPipelineBranchesitem> {
}

export interface GetPipelineBranchesitem {
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "name"?: string;
    "weatherScore"?: number;
    "latestRun"?: GetPipelineBranchesitemLatestRun;
    "organization"?: string;
    "pullRequest"?: GetPipelineBranchesitemPullRequest;
    "totalNumberOfPullRequests"?: number;
    "class"?: string;
}

export interface GetPipelineBranchesitemLatestRun {
    "durationInMillis"?: number;
    "estimatedDurationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
    "class"?: string;
}

export interface GetPipelineBranchesitemPullRequest {
    "links"?: GetPipelineBranchesitemPullRequestLinks;
    "author"?: string;
    "id"?: string;
    "title"?: string;
    "url"?: string;
    "class"?: string;
}

export interface GetPipelineBranchesitemPullRequestLinks {
    "self"?: string;
    "class"?: string;
}

export interface GetPipelines extends Array<SwaggyjenkinsPipeline> {
}

export interface GetUsers extends Array<SwaggyjenkinsUser> {
}

export interface HudsonmodelAllView {
    "class"?: string;
    "name"?: string;
    "url"?: string;
}

export interface HudsonmodelCauseAction {
    "class"?: string;
    "causes"?: Array<HudsonmodelCauseUserIdCause>;
}

export interface HudsonmodelCauseUserIdCause {
    "class"?: string;
    "shortDescription"?: string;
    "userId"?: string;
    "userName"?: string;
}

export interface HudsonmodelComputerSet {
    "class"?: string;
    "busyExecutors"?: number;
    "computer"?: Array<HudsonmodelHudsonMasterComputer>;
    "displayName"?: string;
    "totalExecutors"?: number;
}

export interface HudsonmodelFreeStyleBuild {
    "class"?: string;
    "number"?: number;
    "url"?: string;
    "actions"?: Array<HudsonmodelCauseAction>;
    "building"?: boolean;
    "description"?: string;
    "displayName"?: string;
    "duration"?: number;
    "estimatedDuration"?: number;
    "executor"?: string;
    "fullDisplayName"?: string;
    "id"?: string;
    "keepLog"?: boolean;
    "queueId"?: number;
    "result"?: string;
    "timestamp"?: number;
    "builtOn"?: string;
    "changeSet"?: HudsonscmEmptyChangeLogSet;
}

export interface HudsonmodelFreeStyleProject {
    "class"?: string;
    "name"?: string;
    "url"?: string;
    "color"?: string;
    "actions"?: Array<HudsonmodelFreeStyleProjectactions>;
    "description"?: string;
    "displayName"?: string;
    "displayNameOrNull"?: string;
    "fullDisplayName"?: string;
    "fullName"?: string;
    "buildable"?: boolean;
    "builds"?: Array<HudsonmodelFreeStyleBuild>;
    "firstBuild"?: HudsonmodelFreeStyleBuild;
    "healthReport"?: Array<HudsonmodelFreeStyleProjecthealthReport>;
    "inQueue"?: boolean;
    "keepDependencies"?: boolean;
    "lastBuild"?: HudsonmodelFreeStyleBuild;
    "lastCompletedBuild"?: HudsonmodelFreeStyleBuild;
    "lastFailedBuild"?: string;
    "lastStableBuild"?: HudsonmodelFreeStyleBuild;
    "lastSuccessfulBuild"?: HudsonmodelFreeStyleBuild;
    "lastUnstableBuild"?: string;
    "lastUnsuccessfulBuild"?: string;
    "nextBuildNumber"?: number;
    "queueItem"?: string;
    "concurrentBuild"?: boolean;
    "scm"?: HudsonscmNullSCM;
}

export interface HudsonmodelFreeStyleProjectactions {
    "class"?: string;
}

export interface HudsonmodelFreeStyleProjecthealthReport {
    "description"?: string;
    "iconClassName"?: string;
    "iconUrl"?: string;
    "score"?: number;
    "class"?: string;
}

export interface HudsonmodelHudson {
    "class"?: string;
    "assignedLabels"?: Array<HudsonmodelHudsonassignedLabels>;
    "mode"?: string;
    "nodeDescription"?: string;
    "nodeName"?: string;
    "numExecutors"?: number;
    "description"?: string;
    "jobs"?: Array<HudsonmodelFreeStyleProject>;
    "primaryView"?: HudsonmodelAllView;
    "quietingDown"?: boolean;
    "slaveAgentPort"?: number;
    "unlabeledLoad"?: JenkinsmodelUnlabeledLoadStatistics;
    "useCrumbs"?: boolean;
    "useSecurity"?: boolean;
    "views"?: Array<HudsonmodelAllView>;
}

export interface HudsonmodelHudsonMasterComputer {
    "class"?: string;
    "displayName"?: string;
    "executors"?: Array<HudsonmodelHudsonMasterComputerexecutors>;
    "icon"?: string;
    "iconClassName"?: string;
    "idle"?: boolean;
    "jnlpAgent"?: boolean;
    "launchSupported"?: boolean;
    "loadStatistics"?: HudsonmodelLabel1;
    "manualLaunchAllowed"?: boolean;
    "monitorData"?: HudsonmodelHudsonMasterComputerMonitorData;
    "numExecutors"?: number;
    "offline"?: boolean;
    "offlineCause"?: string;
    "offlineCauseReason"?: string;
    "temporarilyOffline"?: boolean;
}

export interface HudsonmodelHudsonMasterComputerMonitorData {
    "hudsonNodeMonitorsSwapSpaceMonitor"?: HudsonnodeMonitorsSwapSpaceMonitorMemoryUsage2;
    "hudsonNodeMonitorsTemporarySpaceMonitor"?: HudsonnodeMonitorsDiskSpaceMonitorDescriptorDiskSpace;
    "hudsonNodeMonitorsDiskSpaceMonitor"?: HudsonnodeMonitorsDiskSpaceMonitorDescriptorDiskSpace;
    "hudsonNodeMonitorsArchitectureMonitor"?: string;
    "hudsonNodeMonitorsResponseTimeMonitor"?: HudsonnodeMonitorsResponseTimeMonitorData;
    "hudsonNodeMonitorsClockMonitor"?: HudsonutilClockDifference;
    "class"?: string;
}

export interface HudsonmodelHudsonMasterComputerexecutors {
    "currentExecutable"?: HudsonmodelFreeStyleBuild;
    "idle"?: boolean;
    "likelyStuck"?: boolean;
    "number"?: number;
    "progress"?: number;
    "class"?: string;
}

export interface HudsonmodelHudsonassignedLabels {
    "class"?: string;
}

export interface HudsonmodelLabel1 {
    "class"?: string;
}

export interface HudsonmodelListView {
    "class"?: string;
    "description"?: string;
    "jobs"?: Array<HudsonmodelFreeStyleProject>;
    "name"?: string;
    "url"?: string;
}

export interface HudsonmodelQueue {
    "class"?: string;
    "items"?: Array<HudsonmodelQueueBlockedItem>;
}

export interface HudsonmodelQueueBlockedItem {
    "class"?: string;
    "actions"?: Array<HudsonmodelCauseAction>;
    "blocked"?: boolean;
    "buildable"?: boolean;
    "id"?: number;
    "inQueueSince"?: number;
    "params"?: string;
    "stuck"?: boolean;
    "task"?: HudsonmodelFreeStyleProject;
    "url"?: string;
    "why"?: string;
    "buildableStartMilliseconds"?: number;
}

export interface HudsonmodelQueueLeftItem {
    "class"?: string;
    "actions"?: Array<HudsonmodelCauseAction>;
    "blocked"?: boolean;
    "buildable"?: boolean;
    "id"?: number;
    "inQueueSince"?: number;
    "params"?: string;
    "stuck"?: boolean;
    "task"?: HudsonmodelFreeStyleProject;
    "url"?: string;
    "why"?: string;
    "cancelled"?: boolean;
    "executable"?: HudsonmodelFreeStyleBuild;
}

export interface HudsonmodelStringParameterDefinition {
    "class"?: string;
    "defaultParameterValue"?: HudsonmodelStringParameterValue;
    "description"?: string;
    "name"?: string;
    "type"?: string;
}

export interface HudsonmodelStringParameterValue {
    "class"?: string;
    "name"?: string;
    "value"?: string;
}

export interface HudsonnodeMonitorsDiskSpaceMonitorDescriptorDiskSpace {
    "class"?: string;
    "timestamp"?: number;
    "path"?: string;
    "size"?: number;
}

export interface HudsonnodeMonitorsResponseTimeMonitorData {
    "class"?: string;
    "timestamp"?: number;
    "average"?: number;
}

export interface HudsonnodeMonitorsSwapSpaceMonitorMemoryUsage2 {
    "class"?: string;
    "availablePhysicalMemory"?: number;
    "availableSwapSpace"?: number;
    "totalPhysicalMemory"?: number;
    "totalSwapSpace"?: number;
}

export interface HudsonscmEmptyChangeLogSet {
    "class"?: string;
    "kind"?: string;
}

export interface HudsonscmNullSCM {
    "class"?: string;
}

export interface HudsonsecuritycsrfDefaultCrumbIssuer {
    "class"?: string;
    "crumb"?: string;
    "crumbRequestField"?: string;
}

export interface HudsonutilClockDifference {
    "class"?: string;
    "diff"?: number;
}

export interface IojenkinsblueoceanresthalLink {
    "class"?: string;
    "href"?: string;
}

export interface IojenkinsblueoceanrestimplpipelineBranchImpl {
    "class"?: string;
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "fullDisplayName"?: string;
    "fullName"?: string;
    "name"?: string;
    "organization"?: string;
    "parameters"?: Array<HudsonmodelStringParameterDefinition>;
    "permissions"?: IojenkinsblueoceanrestimplpipelineBranchImplPermissions;
    "weatherScore"?: number;
    "pullRequest"?: string;
}

export interface IojenkinsblueoceanrestimplpipelineBranchImplPermissions {
    "create"?: boolean;
    "read"?: boolean;
    "start"?: boolean;
    "stop"?: boolean;
    "class"?: string;
}

export interface IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1 {
    "class"?: string;
    "links"?: IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Links;
    "map"?: IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Map;
}

export interface IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Links {
    "self"?: IojenkinsblueoceanresthalLink;
    "class"?: string;
}

export interface IojenkinsblueoceanserviceembeddedrestExtensionClassContainerImpl1Map {
    "ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl"?: IojenkinsblueoceanserviceembeddedrestExtensionClassImpl;
    "ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl"?: IojenkinsblueoceanserviceembeddedrestExtensionClassImpl;
    "class"?: string;
}

export interface IojenkinsblueoceanserviceembeddedrestExtensionClassImpl {
    "class"?: string;
    "links"?: IojenkinsblueoceanserviceembeddedrestExtensionClassImplLinks;
    "classes"?: Array<string>;
}

export interface IojenkinsblueoceanserviceembeddedrestExtensionClassImplLinks {
    "self"?: IojenkinsblueoceanresthalLink;
    "class"?: string;
}

export interface IojenkinsblueoceanserviceembeddedrestPipelineFolderImpl {
    "class"?: string;
    "displayName"?: string;
    "fullName"?: string;
    "name"?: string;
    "organization"?: string;
    "numberOfFolders"?: number;
    "numberOfPipelines"?: number;
}

export interface IojenkinsblueoceanserviceembeddedrestPipelineImpl {
    "class"?: string;
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "fullName"?: string;
    "latestRun"?: string;
    "name"?: string;
    "organization"?: string;
    "weatherScore"?: number;
}

export interface JenkinsmodelUnlabeledLoadStatistics {
    "class"?: string;
}

export interface SwaggyjenkinsOrganisation {
    "class"?: string;
    "name"?: string;
}

export interface SwaggyjenkinsPipeline {
    "class"?: string;
    "organization"?: string;
    "name"?: string;
    "displayName"?: string;
    "fullName"?: string;
    "weatherScore"?: number;
    "estimatedDurationInMillis"?: number;
    "latestRun"?: SwaggyjenkinsPipelineLatestRun;
}

export interface SwaggyjenkinsPipelineLatestRun {
    "artifacts"?: Array<SwaggyjenkinsPipelineLatestRunartifacts>;
    "durationInMillis"?: number;
    "estimatedDurationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
    "class"?: string;
}

export interface SwaggyjenkinsPipelineLatestRunartifacts {
    "name"?: string;
    "size"?: number;
    "url"?: string;
    "class"?: string;
}

export interface SwaggyjenkinsUser {
    "class"?: string;
    "id"?: string;
    "fullName"?: string;
    "email"?: string;
    "name"?: string;
}



/**
 * BlueOceanApi - fetch parameter creator
 */
export const BlueOceanApiFetchParamCreator = {
    /** 
     * Retrieve authenticated user details for an organisation
     * @param organisation Name of the organisation
     */
    getAuthenticatedUser(params: {  "organisation": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getAuthenticatedUser");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/user/`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    getClasses(params: {  "_class": string; }, options?: any): FetchArgs {
        // verify required parameter "_class" is set
        if (params["_class"] == null) {
            throw new Error("Missing required parameter _class when calling getClasses");
        }
        const baseUrl = `/blue/rest/classes/{class}`
            .replace(`{${"class"}}`, `${ params["_class"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve organisation details
     * @param organisation Name of the organisation
     */
    getOrganisation(params: {  "organisation": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getOrganisation");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve all organisations details
     */
    getOrganisations(options?: any): FetchArgs {
        const baseUrl = `/blue/rest/organizations/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve branch details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    getPipelineBranchByOrg(params: {  "organisation": string; "pipeline": string; "branch": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getPipelineBranchByOrg");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineBranchByOrg");
        }
        // verify required parameter "branch" is set
        if (params["branch"] == null) {
            throw new Error("Missing required parameter branch when calling getPipelineBranchByOrg");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/pipelines/{pipeline}/branches/{branch}/`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"branch"}}`, `${ params["branch"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve all branches details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    getPipelineBranchesByOrg(params: {  "organisation": string; "pipeline": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getPipelineBranchesByOrg");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineBranchesByOrg");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/pipelines/{pipeline}/branches`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve pipeline details for an organisation
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    getPipelineByOrg(params: {  "organisation": string; "pipeline": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getPipelineByOrg");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineByOrg");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/pipelines/{pipeline}`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve pipeline folder for an organisation
     * @param organisation Name of the organisation
     * @param folder Name of the folder
     */
    getPipelineFolderByOrg(params: {  "organisation": string; "folder": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getPipelineFolderByOrg");
        }
        // verify required parameter "folder" is set
        if (params["folder"] == null) {
            throw new Error("Missing required parameter folder when calling getPipelineFolderByOrg");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/pipelines/{folder}/`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`)
            .replace(`{${"folder"}}`, `${ params["folder"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve pipeline details for an organisation folder
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    getPipelineFolderByOrg_1(params: {  "organisation": string; "pipeline": string; "folder": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getPipelineFolderByOrg_1");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineFolderByOrg_1");
        }
        // verify required parameter "folder" is set
        if (params["folder"] == null) {
            throw new Error("Missing required parameter folder when calling getPipelineFolderByOrg_1");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/pipelines/{folder}/pipelines/{pipeline}`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"folder"}}`, `${ params["folder"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve all pipelines details for an organisation
     * @param organisation Name of the organisation
     */
    getPipelinesByOrg(params: {  "organisation": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getPipelinesByOrg");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/pipelines/`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve user details for an organisation
     * @param organisation Name of the organisation
     * @param user Name of the user
     */
    getUser(params: {  "organisation": string; "user": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getUser");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling getUser");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/users/{user}`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`)
            .replace(`{${"user"}}`, `${ params["user"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve users details for an organisation
     * @param organisation Name of the organisation
     */
    getUsers(params: {  "organisation": string; }, options?: any): FetchArgs {
        // verify required parameter "organisation" is set
        if (params["organisation"] == null) {
            throw new Error("Missing required parameter organisation when calling getUsers");
        }
        const baseUrl = `/blue/rest/organizations/{organisation}/users/`
            .replace(`{${"organisation"}}`, `${ params["organisation"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get classes details
     * @param q Query string containing an array of class names
     */
    search(params: {  "q": string; }, options?: any): FetchArgs {
        // verify required parameter "q" is set
        if (params["q"] == null) {
            throw new Error("Missing required parameter q when calling search");
        }
        const baseUrl = `/blue/rest/classes/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "q": params["q"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Search for any resource details
     * @param q Query string
     */
    search_2(params: {  "q": string; }, options?: any): FetchArgs {
        // verify required parameter "q" is set
        if (params["q"] == null) {
            throw new Error("Missing required parameter q when calling search_2");
        }
        const baseUrl = `/blue/rest/search/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "q": params["q"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BlueOceanApi - functional programming interface
 */
export const BlueOceanApiFp = {
    /** 
     * Retrieve authenticated user details for an organisation
     * @param organisation Name of the organisation
     */
    getAuthenticatedUser(params: { "organisation": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SwaggyjenkinsUser> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getAuthenticatedUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    getClasses(params: { "_class": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getClasses(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve organisation details
     * @param organisation Name of the organisation
     */
    getOrganisation(params: { "organisation": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SwaggyjenkinsOrganisation> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getOrganisation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve all organisations details
     */
    getOrganisations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetOrganisations> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getOrganisations(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve branch details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    getPipelineBranchByOrg(params: { "organisation": string; "pipeline": string; "branch": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IojenkinsblueoceanrestimplpipelineBranchImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineBranchByOrg(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve all branches details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    getPipelineBranchesByOrg(params: { "organisation": string; "pipeline": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetMultibranchPipeline> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineBranchesByOrg(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve pipeline details for an organisation
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    getPipelineByOrg(params: { "organisation": string; "pipeline": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SwaggyjenkinsPipeline> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineByOrg(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve pipeline folder for an organisation
     * @param organisation Name of the organisation
     * @param folder Name of the folder
     */
    getPipelineFolderByOrg(params: { "organisation": string; "folder": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IojenkinsblueoceanserviceembeddedrestPipelineFolderImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineFolderByOrg(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve pipeline details for an organisation folder
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    getPipelineFolderByOrg_1(params: { "organisation": string; "pipeline": string; "folder": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<IojenkinsblueoceanserviceembeddedrestPipelineImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineFolderByOrg_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve all pipelines details for an organisation
     * @param organisation Name of the organisation
     */
    getPipelinesByOrg(params: { "organisation": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GetPipelines> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelinesByOrg(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve user details for an organisation
     * @param organisation Name of the organisation
     * @param user Name of the user
     */
    getUser(params: { "organisation": string; "user": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SwaggyjenkinsUser> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve users details for an organisation
     * @param organisation Name of the organisation
     */
    getUsers(params: { "organisation": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SwaggyjenkinsUser> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get classes details
     * @param q Query string containing an array of class names
     */
    search(params: { "q": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.search(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Search for any resource details
     * @param q Query string
     */
    search_2(params: { "q": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.search_2(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BlueOceanApi - object-oriented interface
 */
export class BlueOceanApi extends BaseAPI {
    /** 
     * Retrieve authenticated user details for an organisation
     * @param organisation Name of the organisation
     */
    getAuthenticatedUser(params: {  "organisation": string; }, options?: any) {
        return BlueOceanApiFp.getAuthenticatedUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    getClasses(params: {  "_class": string; }, options?: any) {
        return BlueOceanApiFp.getClasses(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve organisation details
     * @param organisation Name of the organisation
     */
    getOrganisation(params: {  "organisation": string; }, options?: any) {
        return BlueOceanApiFp.getOrganisation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve all organisations details
     */
    getOrganisations(options?: any) {
        return BlueOceanApiFp.getOrganisations(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve branch details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    getPipelineBranchByOrg(params: {  "organisation": string; "pipeline": string; "branch": string; }, options?: any) {
        return BlueOceanApiFp.getPipelineBranchByOrg(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve all branches details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    getPipelineBranchesByOrg(params: {  "organisation": string; "pipeline": string; }, options?: any) {
        return BlueOceanApiFp.getPipelineBranchesByOrg(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve pipeline details for an organisation
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    getPipelineByOrg(params: {  "organisation": string; "pipeline": string; }, options?: any) {
        return BlueOceanApiFp.getPipelineByOrg(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve pipeline folder for an organisation
     * @param organisation Name of the organisation
     * @param folder Name of the folder
     */
    getPipelineFolderByOrg(params: {  "organisation": string; "folder": string; }, options?: any) {
        return BlueOceanApiFp.getPipelineFolderByOrg(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve pipeline details for an organisation folder
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    getPipelineFolderByOrg_1(params: {  "organisation": string; "pipeline": string; "folder": string; }, options?: any) {
        return BlueOceanApiFp.getPipelineFolderByOrg_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve all pipelines details for an organisation
     * @param organisation Name of the organisation
     */
    getPipelinesByOrg(params: {  "organisation": string; }, options?: any) {
        return BlueOceanApiFp.getPipelinesByOrg(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve user details for an organisation
     * @param organisation Name of the organisation
     * @param user Name of the user
     */
    getUser(params: {  "organisation": string; "user": string; }, options?: any) {
        return BlueOceanApiFp.getUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve users details for an organisation
     * @param organisation Name of the organisation
     */
    getUsers(params: {  "organisation": string; }, options?: any) {
        return BlueOceanApiFp.getUsers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get classes details
     * @param q Query string containing an array of class names
     */
    search(params: {  "q": string; }, options?: any) {
        return BlueOceanApiFp.search(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Search for any resource details
     * @param q Query string
     */
    search_2(params: {  "q": string; }, options?: any) {
        return BlueOceanApiFp.search_2(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BlueOceanApi - factory interface
 */
export const BlueOceanApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve authenticated user details for an organisation
         * @param organisation Name of the organisation
         */
        getAuthenticatedUser(params: {  "organisation": string; }, options?: any) {
            return BlueOceanApiFp.getAuthenticatedUser(params, options)(fetch, basePath);
        },
        /** 
         * Get a list of class names supported by a given class
         * @param _class Name of the class
         */
        getClasses(params: {  "_class": string; }, options?: any) {
            return BlueOceanApiFp.getClasses(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve organisation details
         * @param organisation Name of the organisation
         */
        getOrganisation(params: {  "organisation": string; }, options?: any) {
            return BlueOceanApiFp.getOrganisation(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve all organisations details
         */
        getOrganisations(options?: any) {
            return BlueOceanApiFp.getOrganisations(options)(fetch, basePath);
        },
        /** 
         * Retrieve branch details for an organisation pipeline
         * @param organisation Name of the organisation
         * @param pipeline Name of the pipeline
         * @param branch Name of the branch
         */
        getPipelineBranchByOrg(params: {  "organisation": string; "pipeline": string; "branch": string; }, options?: any) {
            return BlueOceanApiFp.getPipelineBranchByOrg(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve all branches details for an organisation pipeline
         * @param organisation Name of the organisation
         * @param pipeline Name of the pipeline
         */
        getPipelineBranchesByOrg(params: {  "organisation": string; "pipeline": string; }, options?: any) {
            return BlueOceanApiFp.getPipelineBranchesByOrg(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve pipeline details for an organisation
         * @param organisation Name of the organisation
         * @param pipeline Name of the pipeline
         */
        getPipelineByOrg(params: {  "organisation": string; "pipeline": string; }, options?: any) {
            return BlueOceanApiFp.getPipelineByOrg(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve pipeline folder for an organisation
         * @param organisation Name of the organisation
         * @param folder Name of the folder
         */
        getPipelineFolderByOrg(params: {  "organisation": string; "folder": string; }, options?: any) {
            return BlueOceanApiFp.getPipelineFolderByOrg(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve pipeline details for an organisation folder
         * @param organisation Name of the organisation
         * @param pipeline Name of the pipeline
         * @param folder Name of the folder
         */
        getPipelineFolderByOrg_1(params: {  "organisation": string; "pipeline": string; "folder": string; }, options?: any) {
            return BlueOceanApiFp.getPipelineFolderByOrg_1(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve all pipelines details for an organisation
         * @param organisation Name of the organisation
         */
        getPipelinesByOrg(params: {  "organisation": string; }, options?: any) {
            return BlueOceanApiFp.getPipelinesByOrg(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve user details for an organisation
         * @param organisation Name of the organisation
         * @param user Name of the user
         */
        getUser(params: {  "organisation": string; "user": string; }, options?: any) {
            return BlueOceanApiFp.getUser(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve users details for an organisation
         * @param organisation Name of the organisation
         */
        getUsers(params: {  "organisation": string; }, options?: any) {
            return BlueOceanApiFp.getUsers(params, options)(fetch, basePath);
        },
        /** 
         * Get classes details
         * @param q Query string containing an array of class names
         */
        search(params: {  "q": string; }, options?: any) {
            return BlueOceanApiFp.search(params, options)(fetch, basePath);
        },
        /** 
         * Search for any resource details
         * @param q Query string
         */
        search_2(params: {  "q": string; }, options?: any) {
            return BlueOceanApiFp.search_2(params, options)(fetch, basePath);
        },
    };
};


/**
 * RemoteAccessApi - fetch parameter creator
 */
export const RemoteAccessApiFetchParamCreator = {
    /** 
     * Retrieve computer details
     */
    getComputer(options?: any): FetchArgs {
        const baseUrl = `/computer/api/json?depth=1`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve CSRF protection token
     */
    getCrumb(options?: any): FetchArgs {
        const baseUrl = `/crumbIssuer/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve Jenkins details
     */
    getJenkins(options?: any): FetchArgs {
        const baseUrl = `/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve job details
     * @param name Name of the job
     */
    getJob(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJob");
        }
        const baseUrl = `/job/{name}/api/json`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve job configuration
     * @param name Name of the job
     */
    getJobConfig(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJobConfig");
        }
        const baseUrl = `/job/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve job&#39;s last build details
     * @param name Name of the job
     */
    getJobLastBuild(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJobLastBuild");
        }
        const baseUrl = `/job/{name}/lastBuild/api/json`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve job&#39;s build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    getJobProgressiveText(params: {  "name": string; "number": string; "start": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJobProgressiveText");
        }
        // verify required parameter "number" is set
        if (params["number"] == null) {
            throw new Error("Missing required parameter number when calling getJobProgressiveText");
        }
        // verify required parameter "start" is set
        if (params["start"] == null) {
            throw new Error("Missing required parameter start when calling getJobProgressiveText");
        }
        const baseUrl = `/job/{name}/{number}/logText/progressiveText`
            .replace(`{${"name"}}`, `${ params["name"] }`)
            .replace(`{${"number"}}`, `${ params["number"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start": params["start"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve queue details
     */
    getQueue(options?: any): FetchArgs {
        const baseUrl = `/queue/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve queued item details
     * @param number Queue number
     */
    getQueueItem(params: {  "number": string; }, options?: any): FetchArgs {
        // verify required parameter "number" is set
        if (params["number"] == null) {
            throw new Error("Missing required parameter number when calling getQueueItem");
        }
        const baseUrl = `/queue/item/{number}/api/json`
            .replace(`{${"number"}}`, `${ params["number"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve view details
     * @param name Name of the view
     */
    getView(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getView");
        }
        const baseUrl = `/view/{name}/api/json`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve view configuration
     * @param name Name of the view
     */
    getViewConfig(params: {  "name": string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getViewConfig");
        }
        const baseUrl = `/view/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieve Jenkins headers
     */
    headJenkins(options?: any): FetchArgs {
        const baseUrl = `/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateItem(params: {  "name": string; "from"?: string; "mode"?: string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postCreateItem");
        }
        const baseUrl = `/createItem`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "name": params["name"],
            "from": params["from"],
            "mode": params["mode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],"Content-Type": params["contentType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateView(params: {  "name": string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postCreateView");
        }
        const baseUrl = `/createView`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "name": params["name"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],"Content-Type": params["contentType"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    postJobBuild(params: {  "name": string; "json": string; "token"?: string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobBuild");
        }
        // verify required parameter "json" is set
        if (params["json"] == null) {
            throw new Error("Missing required parameter json when calling postJobBuild");
        }
        const baseUrl = `/job/{name}/build`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "json": params["json"],
            "token": params["token"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postJobConfig(params: {  "name": string; "body": string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobConfig");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling postJobConfig");
        }
        const baseUrl = `/job/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDelete(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobDelete");
        }
        const baseUrl = `/job/{name}/doDelete`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDisable(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobDisable");
        }
        const baseUrl = `/job/{name}/disable`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobEnable(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobEnable");
        }
        const baseUrl = `/job/{name}/enable`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobLastBuildStop(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobLastBuildStop");
        }
        const baseUrl = `/job/{name}/lastBuild/stop`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postViewConfig(params: {  "name": string; "body": string; "jenkinsCrumb"?: string; }, options?: any): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postViewConfig");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling postViewConfig");
        }
        const baseUrl = `/view/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RemoteAccessApi - functional programming interface
 */
export const RemoteAccessApiFp = {
    /** 
     * Retrieve computer details
     */
    getComputer(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelComputerSet> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getComputer(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve CSRF protection token
     */
    getCrumb(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonsecuritycsrfDefaultCrumbIssuer> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getCrumb(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve Jenkins details
     */
    getJenkins(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelHudson> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJenkins(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve job details
     * @param name Name of the job
     */
    getJob(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelFreeStyleProject> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJob(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve job configuration
     * @param name Name of the job
     */
    getJobConfig(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJobConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve job&#39;s last build details
     * @param name Name of the job
     */
    getJobLastBuild(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelFreeStyleBuild> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJobLastBuild(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve job&#39;s build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    getJobProgressiveText(params: { "name": string; "number": string; "start": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJobProgressiveText(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve queue details
     */
    getQueue(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelQueue> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getQueue(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve queued item details
     * @param number Queue number
     */
    getQueueItem(params: { "number": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelQueue> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getQueueItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve view details
     * @param name Name of the view
     */
    getView(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HudsonmodelListView> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getView(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve view configuration
     * @param name Name of the view
     */
    getViewConfig(params: { "name": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getViewConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieve Jenkins headers
     */
    headJenkins(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.headJenkins(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateItem(params: { "name": string; "from"?: string; "mode"?: string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postCreateItem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateView(params: { "name": string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postCreateView(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    postJobBuild(params: { "name": string; "json": string; "token"?: string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobBuild(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postJobConfig(params: { "name": string; "body": string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDelete(params: { "name": string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDisable(params: { "name": string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobDisable(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobEnable(params: { "name": string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobEnable(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobLastBuildStop(params: { "name": string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobLastBuildStop(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postViewConfig(params: { "name": string; "body": string; "jenkinsCrumb"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postViewConfig(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RemoteAccessApi - object-oriented interface
 */
export class RemoteAccessApi extends BaseAPI {
    /** 
     * Retrieve computer details
     */
    getComputer(options?: any) {
        return RemoteAccessApiFp.getComputer(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve CSRF protection token
     */
    getCrumb(options?: any) {
        return RemoteAccessApiFp.getCrumb(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve Jenkins details
     */
    getJenkins(options?: any) {
        return RemoteAccessApiFp.getJenkins(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve job details
     * @param name Name of the job
     */
    getJob(params: {  "name": string; }, options?: any) {
        return RemoteAccessApiFp.getJob(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve job configuration
     * @param name Name of the job
     */
    getJobConfig(params: {  "name": string; }, options?: any) {
        return RemoteAccessApiFp.getJobConfig(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve job&#39;s last build details
     * @param name Name of the job
     */
    getJobLastBuild(params: {  "name": string; }, options?: any) {
        return RemoteAccessApiFp.getJobLastBuild(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve job&#39;s build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    getJobProgressiveText(params: {  "name": string; "number": string; "start": string; }, options?: any) {
        return RemoteAccessApiFp.getJobProgressiveText(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve queue details
     */
    getQueue(options?: any) {
        return RemoteAccessApiFp.getQueue(options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve queued item details
     * @param number Queue number
     */
    getQueueItem(params: {  "number": string; }, options?: any) {
        return RemoteAccessApiFp.getQueueItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve view details
     * @param name Name of the view
     */
    getView(params: {  "name": string; }, options?: any) {
        return RemoteAccessApiFp.getView(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve view configuration
     * @param name Name of the view
     */
    getViewConfig(params: {  "name": string; }, options?: any) {
        return RemoteAccessApiFp.getViewConfig(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieve Jenkins headers
     */
    headJenkins(options?: any) {
        return RemoteAccessApiFp.headJenkins(options)(this.fetch, this.basePath);
    }
    /** 
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateItem(params: {  "name": string; "from"?: string; "mode"?: string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string; }, options?: any) {
        return RemoteAccessApiFp.postCreateItem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateView(params: {  "name": string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string; }, options?: any) {
        return RemoteAccessApiFp.postCreateView(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    postJobBuild(params: {  "name": string; "json": string; "token"?: string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postJobBuild(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postJobConfig(params: {  "name": string; "body": string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postJobConfig(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDelete(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postJobDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDisable(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postJobDisable(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobEnable(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postJobEnable(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobLastBuildStop(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postJobLastBuildStop(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postViewConfig(params: {  "name": string; "body": string; "jenkinsCrumb"?: string; }, options?: any) {
        return RemoteAccessApiFp.postViewConfig(params, options)(this.fetch, this.basePath);
    }
};

/**
 * RemoteAccessApi - factory interface
 */
export const RemoteAccessApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Retrieve computer details
         */
        getComputer(options?: any) {
            return RemoteAccessApiFp.getComputer(options)(fetch, basePath);
        },
        /** 
         * Retrieve CSRF protection token
         */
        getCrumb(options?: any) {
            return RemoteAccessApiFp.getCrumb(options)(fetch, basePath);
        },
        /** 
         * Retrieve Jenkins details
         */
        getJenkins(options?: any) {
            return RemoteAccessApiFp.getJenkins(options)(fetch, basePath);
        },
        /** 
         * Retrieve job details
         * @param name Name of the job
         */
        getJob(params: {  "name": string; }, options?: any) {
            return RemoteAccessApiFp.getJob(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve job configuration
         * @param name Name of the job
         */
        getJobConfig(params: {  "name": string; }, options?: any) {
            return RemoteAccessApiFp.getJobConfig(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve job&#39;s last build details
         * @param name Name of the job
         */
        getJobLastBuild(params: {  "name": string; }, options?: any) {
            return RemoteAccessApiFp.getJobLastBuild(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve job&#39;s build progressive text output
         * @param name Name of the job
         * @param number Build number
         * @param start Starting point of progressive text output
         */
        getJobProgressiveText(params: {  "name": string; "number": string; "start": string; }, options?: any) {
            return RemoteAccessApiFp.getJobProgressiveText(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve queue details
         */
        getQueue(options?: any) {
            return RemoteAccessApiFp.getQueue(options)(fetch, basePath);
        },
        /** 
         * Retrieve queued item details
         * @param number Queue number
         */
        getQueueItem(params: {  "number": string; }, options?: any) {
            return RemoteAccessApiFp.getQueueItem(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve view details
         * @param name Name of the view
         */
        getView(params: {  "name": string; }, options?: any) {
            return RemoteAccessApiFp.getView(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve view configuration
         * @param name Name of the view
         */
        getViewConfig(params: {  "name": string; }, options?: any) {
            return RemoteAccessApiFp.getViewConfig(params, options)(fetch, basePath);
        },
        /** 
         * Retrieve Jenkins headers
         */
        headJenkins(options?: any) {
            return RemoteAccessApiFp.headJenkins(options)(fetch, basePath);
        },
        /** 
         * Create a new job using job configuration, or copied from an existing job
         * @param name Name of the new job
         * @param from Existing job to copy from
         * @param mode Set to &#39;copy&#39; for copying an existing job
         * @param body Job configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         * @param contentType Content type header application/xml
         */
        postCreateItem(params: {  "name": string; "from"?: string; "mode"?: string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string; }, options?: any) {
            return RemoteAccessApiFp.postCreateItem(params, options)(fetch, basePath);
        },
        /** 
         * Create a new view using view configuration
         * @param name Name of the new view
         * @param body View configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         * @param contentType Content type header application/xml
         */
        postCreateView(params: {  "name": string; "body"?: string; "jenkinsCrumb"?: string; "contentType"?: string; }, options?: any) {
            return RemoteAccessApiFp.postCreateView(params, options)(fetch, basePath);
        },
        /** 
         * Build a job
         * @param name Name of the job
         * @param json 
         * @param token 
         * @param jenkinsCrumb CSRF protection token
         */
        postJobBuild(params: {  "name": string; "json": string; "token"?: string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postJobBuild(params, options)(fetch, basePath);
        },
        /** 
         * Update job configuration
         * @param name Name of the job
         * @param body Job configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         */
        postJobConfig(params: {  "name": string; "body": string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postJobConfig(params, options)(fetch, basePath);
        },
        /** 
         * Delete a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobDelete(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postJobDelete(params, options)(fetch, basePath);
        },
        /** 
         * Disable a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobDisable(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postJobDisable(params, options)(fetch, basePath);
        },
        /** 
         * Enable a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobEnable(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postJobEnable(params, options)(fetch, basePath);
        },
        /** 
         * Stop a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobLastBuildStop(params: {  "name": string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postJobLastBuildStop(params, options)(fetch, basePath);
        },
        /** 
         * Update view configuration
         * @param name Name of the view
         * @param body View configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         */
        postViewConfig(params: {  "name": string; "body": string; "jenkinsCrumb"?: string; }, options?: any) {
            return RemoteAccessApiFp.postViewConfig(params, options)(fetch, basePath);
        },
    };
};

