/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

import { Configuration } from "./configuration";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://localhost".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    public configuration: Configuration;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH, configuration: Configuration = new Configuration()) {
        this.basePath = basePath;
        this.fetch = fetch;
        this.configuration = configuration;
    }
};

export interface AllView {
    "class"?: string;
    "name"?: string;
    "url"?: string;
}

export interface Body {
    "favorite": boolean;
}

export interface BranchImpl {
    "class"?: string;
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "fullDisplayName"?: string;
    "fullName"?: string;
    "name"?: string;
    "organization"?: string;
    "parameters"?: Array<StringParameterDefinition>;
    "permissions"?: BranchImplpermissions;
    "weatherScore"?: number;
    "pullRequest"?: string;
    "links"?: BranchImpllinks;
    "latestRun"?: PipelineRunImpl;
}

export interface BranchImpllinks {
    "self"?: Link;
    "actions"?: Link;
    "runs"?: Link;
    "queue"?: Link;
    "class"?: string;
}

export interface BranchImplpermissions {
    "create"?: boolean;
    "read"?: boolean;
    "start"?: boolean;
    "stop"?: boolean;
    "class"?: string;
}

export interface CauseAction {
    "class"?: string;
    "causes"?: Array<CauseUserIdCause>;
}

export interface CauseUserIdCause {
    "class"?: string;
    "shortDescription"?: string;
    "userId"?: string;
    "userName"?: string;
}

export interface ClassesByClass {
    "classes"?: Array<string>;
    "class"?: string;
}

export interface ClockDifference {
    "class"?: string;
    "diff"?: number;
}

export interface ComputerSet {
    "class"?: string;
    "busyExecutors"?: number;
    "computer"?: Array<HudsonMasterComputer>;
    "displayName"?: string;
    "totalExecutors"?: number;
}

export interface DefaultCrumbIssuer {
    "class"?: string;
    "crumb"?: string;
    "crumbRequestField"?: string;
}

export interface DiskSpaceMonitorDescriptorDiskSpace {
    "class"?: string;
    "timestamp"?: number;
    "path"?: string;
    "size"?: number;
}

export interface EmptyChangeLogSet {
    "class"?: string;
    "kind"?: string;
}

export interface ExtensionClassContainerImpl1 {
    "class"?: string;
    "links"?: ExtensionClassContainerImpl1links;
    "map"?: ExtensionClassContainerImpl1map;
}

export interface ExtensionClassContainerImpl1links {
    "self"?: Link;
    "class"?: string;
}

export interface ExtensionClassContainerImpl1map {
    "ioJenkinsBlueoceanServiceEmbeddedRestPipelineImpl"?: ExtensionClassImpl;
    "ioJenkinsBlueoceanServiceEmbeddedRestMultiBranchPipelineImpl"?: ExtensionClassImpl;
    "class"?: string;
}

export interface ExtensionClassImpl {
    "class"?: string;
    "links"?: ExtensionClassImpllinks;
    "classes"?: Array<string>;
}

export interface ExtensionClassImpllinks {
    "self"?: Link;
    "class"?: string;
}

export interface FavoriteImpl {
    "class"?: string;
    "links"?: FavoriteImpllinks;
    "item"?: PipelineImpl;
}

export interface FavoriteImpllinks {
    "self"?: Link;
    "class"?: string;
}

export interface FreeStyleBuild {
    "class"?: string;
    "number"?: number;
    "url"?: string;
    "actions"?: Array<CauseAction>;
    "building"?: boolean;
    "description"?: string;
    "displayName"?: string;
    "duration"?: number;
    "estimatedDuration"?: number;
    "executor"?: string;
    "fullDisplayName"?: string;
    "id"?: string;
    "keepLog"?: boolean;
    "queueId"?: number;
    "result"?: string;
    "timestamp"?: number;
    "builtOn"?: string;
    "changeSet"?: EmptyChangeLogSet;
}

export interface FreeStyleProject {
    "class"?: string;
    "name"?: string;
    "url"?: string;
    "color"?: string;
    "actions"?: Array<FreeStyleProjectactions>;
    "description"?: string;
    "displayName"?: string;
    "displayNameOrNull"?: string;
    "fullDisplayName"?: string;
    "fullName"?: string;
    "buildable"?: boolean;
    "builds"?: Array<FreeStyleBuild>;
    "firstBuild"?: FreeStyleBuild;
    "healthReport"?: Array<FreeStyleProjecthealthReport>;
    "inQueue"?: boolean;
    "keepDependencies"?: boolean;
    "lastBuild"?: FreeStyleBuild;
    "lastCompletedBuild"?: FreeStyleBuild;
    "lastFailedBuild"?: string;
    "lastStableBuild"?: FreeStyleBuild;
    "lastSuccessfulBuild"?: FreeStyleBuild;
    "lastUnstableBuild"?: string;
    "lastUnsuccessfulBuild"?: string;
    "nextBuildNumber"?: number;
    "queueItem"?: string;
    "concurrentBuild"?: boolean;
    "scm"?: NullSCM;
}

export interface FreeStyleProjectactions {
    "class"?: string;
}

export interface FreeStyleProjecthealthReport {
    "description"?: string;
    "iconClassName"?: string;
    "iconUrl"?: string;
    "score"?: number;
    "class"?: string;
}

export interface GenericResource {
    "class"?: string;
    "displayName"?: string;
    "durationInMillis"?: number;
    "id"?: string;
    "result"?: string;
    "startTime"?: string;
}

export interface GithubContent {
    "name"?: string;
    "sha"?: string;
    "class"?: string;
    "repo"?: string;
    "size"?: number;
    "owner"?: string;
    "path"?: string;
    "base64Data"?: string;
}

export interface GithubFile {
    "content"?: GithubContent;
    "class"?: string;
}

export interface GithubOrganization {
    "class"?: string;
    "links"?: GithubOrganizationlinks;
    "jenkinsOrganizationPipeline"?: boolean;
    "name"?: string;
}

export interface GithubOrganizationlinks {
    "repositories"?: Link;
    "self"?: Link;
    "class"?: string;
}

export interface GithubRepositories {
    "class"?: string;
    "links"?: GithubRepositorieslinks;
    "items"?: Array<GithubRepository>;
    "lastPage"?: number;
    "nextPage"?: number;
    "pageSize"?: number;
}

export interface GithubRepositorieslinks {
    "self"?: Link;
    "class"?: string;
}

export interface GithubRepository {
    "class"?: string;
    "links"?: GithubRepositorylinks;
    "defaultBranch"?: string;
    "description"?: string;
    "name"?: string;
    "permissions"?: GithubRepositorypermissions;
    "private"?: boolean;
    "fullName"?: string;
}

export interface GithubRepositorylinks {
    "self"?: Link;
    "class"?: string;
}

export interface GithubRepositorypermissions {
    "admin"?: boolean;
    "push"?: boolean;
    "pull"?: boolean;
    "class"?: string;
}

export interface GithubRespositoryContainer {
    "class"?: string;
    "links"?: GithubRespositoryContainerlinks;
    "repositories"?: GithubRepositories;
}

export interface GithubRespositoryContainerlinks {
    "self"?: Link;
    "class"?: string;
}

export interface GithubScm {
    "class"?: string;
    "links"?: GithubScmlinks;
    "credentialId"?: string;
    "id"?: string;
    "uri"?: string;
}

export interface GithubScmlinks {
    "self"?: Link;
    "class"?: string;
}

export interface Hudson {
    "class"?: string;
    "assignedLabels"?: Array<HudsonassignedLabels>;
    "mode"?: string;
    "nodeDescription"?: string;
    "nodeName"?: string;
    "numExecutors"?: number;
    "description"?: string;
    "jobs"?: Array<FreeStyleProject>;
    "primaryView"?: AllView;
    "quietingDown"?: boolean;
    "slaveAgentPort"?: number;
    "unlabeledLoad"?: UnlabeledLoadStatistics;
    "useCrumbs"?: boolean;
    "useSecurity"?: boolean;
    "views"?: Array<AllView>;
}

export interface HudsonMasterComputer {
    "class"?: string;
    "displayName"?: string;
    "executors"?: Array<HudsonMasterComputerexecutors>;
    "icon"?: string;
    "iconClassName"?: string;
    "idle"?: boolean;
    "jnlpAgent"?: boolean;
    "launchSupported"?: boolean;
    "loadStatistics"?: Label1;
    "manualLaunchAllowed"?: boolean;
    "monitorData"?: HudsonMasterComputermonitorData;
    "numExecutors"?: number;
    "offline"?: boolean;
    "offlineCause"?: string;
    "offlineCauseReason"?: string;
    "temporarilyOffline"?: boolean;
}

export interface HudsonMasterComputerexecutors {
    "currentExecutable"?: FreeStyleBuild;
    "idle"?: boolean;
    "likelyStuck"?: boolean;
    "number"?: number;
    "progress"?: number;
    "class"?: string;
}

export interface HudsonMasterComputermonitorData {
    "hudsonNodeMonitorsSwapSpaceMonitor"?: SwapSpaceMonitorMemoryUsage2;
    "hudsonNodeMonitorsTemporarySpaceMonitor"?: DiskSpaceMonitorDescriptorDiskSpace;
    "hudsonNodeMonitorsDiskSpaceMonitor"?: DiskSpaceMonitorDescriptorDiskSpace;
    "hudsonNodeMonitorsArchitectureMonitor"?: string;
    "hudsonNodeMonitorsResponseTimeMonitor"?: ResponseTimeMonitorData;
    "hudsonNodeMonitorsClockMonitor"?: ClockDifference;
    "class"?: string;
}

export interface HudsonassignedLabels {
    "class"?: string;
}

export interface InputStepImpl {
    "class"?: string;
    "links"?: InputStepImpllinks;
    "id"?: string;
    "message"?: string;
    "ok"?: string;
    "parameters"?: Array<StringParameterDefinition>;
    "submitter"?: string;
}

export interface InputStepImpllinks {
    "self"?: Link;
    "class"?: string;
}

export interface Label1 {
    "class"?: string;
}

export interface Link {
    "class"?: string;
    "href"?: string;
}

export interface ListView {
    "class"?: string;
    "description"?: string;
    "jobs"?: Array<FreeStyleProject>;
    "name"?: string;
    "url"?: string;
}

export interface MultibranchPipeline {
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "latestRun"?: string;
    "name"?: string;
    "organization"?: string;
    "weatherScore"?: number;
    "branchNames"?: Array<string>;
    "numberOfFailingBranches"?: number;
    "numberOfFailingPullRequests"?: number;
    "numberOfSuccessfulBranches"?: number;
    "numberOfSuccessfulPullRequests"?: number;
    "totalNumberOfBranches"?: number;
    "totalNumberOfPullRequests"?: number;
    "class"?: string;
}

export interface NullSCM {
    "class"?: string;
}

export interface Organisation {
    "class"?: string;
    "name"?: string;
}

export interface Organisations extends Array<Organisation> {
}

export interface Pipeline {
    "class"?: string;
    "organization"?: string;
    "name"?: string;
    "displayName"?: string;
    "fullName"?: string;
    "weatherScore"?: number;
    "estimatedDurationInMillis"?: number;
    "latestRun"?: PipelinelatestRun;
}

export interface PipelineActivities extends Array<PipelineActivity> {
}

export interface PipelineActivity {
    "class"?: string;
    "artifacts"?: Array<PipelineActivityartifacts>;
    "durationInMillis"?: number;
    "estimatedDurationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
}

export interface PipelineActivityartifacts {
    "name"?: string;
    "size"?: number;
    "url"?: string;
    "class"?: string;
}

export interface PipelineBranches extends Array<PipelineBranchesitem> {
}

export interface PipelineBranchesitem {
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "name"?: string;
    "weatherScore"?: number;
    "latestRun"?: PipelineBranchesitemlatestRun;
    "organization"?: string;
    "pullRequest"?: PipelineBranchesitempullRequest;
    "totalNumberOfPullRequests"?: number;
    "class"?: string;
}

export interface PipelineBranchesitemlatestRun {
    "durationInMillis"?: number;
    "estimatedDurationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
    "class"?: string;
}

export interface PipelineBranchesitempullRequest {
    "links"?: PipelineBranchesitempullRequestlinks;
    "author"?: string;
    "id"?: string;
    "title"?: string;
    "url"?: string;
    "class"?: string;
}

export interface PipelineBranchesitempullRequestlinks {
    "self"?: string;
    "class"?: string;
}

export interface PipelineFolderImpl {
    "class"?: string;
    "displayName"?: string;
    "fullName"?: string;
    "name"?: string;
    "organization"?: string;
    "numberOfFolders"?: number;
    "numberOfPipelines"?: number;
}

export interface PipelineImpl {
    "class"?: string;
    "displayName"?: string;
    "estimatedDurationInMillis"?: number;
    "fullName"?: string;
    "latestRun"?: string;
    "name"?: string;
    "organization"?: string;
    "weatherScore"?: number;
    "links"?: PipelineImpllinks;
}

export interface PipelineImpllinks {
    "runs"?: Link;
    "self"?: Link;
    "queue"?: Link;
    "actions"?: Link;
    "class"?: string;
}

export interface PipelineQueue extends Array<QueueItemImpl> {
}

export interface PipelineRun {
    "class"?: string;
    "artifacts"?: Array<PipelineRunartifacts>;
    "durationInMillis"?: number;
    "estimatedDurationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
}

export interface PipelineRunImpl {
    "class"?: string;
    "links"?: PipelineRunImpllinks;
    "durationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "estimatedDurationInMillis"?: number;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
}

export interface PipelineRunImpllinks {
    "nodes"?: Link;
    "log"?: Link;
    "self"?: Link;
    "actions"?: Link;
    "steps"?: Link;
    "class"?: string;
}

export interface PipelineRunNode {
    "class"?: string;
    "displayName"?: string;
    "durationInMillis"?: number;
    "edges"?: Array<PipelineRunNodeedges>;
    "id"?: string;
    "result"?: string;
    "startTime"?: string;
    "state"?: string;
}

export interface PipelineRunNodeSteps extends Array<PipelineStepImpl> {
}

export interface PipelineRunNodeedges {
    "id"?: string;
    "class"?: string;
}

export interface PipelineRunNodes extends Array<PipelineRunNode> {
}

export interface PipelineRunSteps extends Array<GenericResource> {
}

export interface PipelineRunartifacts {
    "name"?: string;
    "size"?: number;
    "url"?: string;
    "class"?: string;
}

export interface PipelineRuns extends Array<PipelineRun> {
}

export interface PipelineStepImpl {
    "class"?: string;
    "links"?: PipelineStepImpllinks;
    "displayName"?: string;
    "durationInMillis"?: number;
    "id"?: string;
    "input"?: InputStepImpl;
    "result"?: string;
    "startTime"?: string;
    "state"?: string;
}

export interface PipelineStepImpllinks {
    "self"?: Link;
    "actions"?: Link;
    "class"?: string;
}

export interface PipelinelatestRun {
    "artifacts"?: Array<PipelinelatestRunartifacts>;
    "durationInMillis"?: number;
    "estimatedDurationInMillis"?: number;
    "enQueueTime"?: string;
    "endTime"?: string;
    "id"?: string;
    "organization"?: string;
    "pipeline"?: string;
    "result"?: string;
    "runSummary"?: string;
    "startTime"?: string;
    "state"?: string;
    "type"?: string;
    "commitId"?: string;
    "class"?: string;
}

export interface PipelinelatestRunartifacts {
    "name"?: string;
    "size"?: number;
    "url"?: string;
    "class"?: string;
}

export interface Pipelines extends Array<Pipeline> {
}

export interface Queue {
    "class"?: string;
    "items"?: Array<QueueBlockedItem>;
}

export interface QueueBlockedItem {
    "class"?: string;
    "actions"?: Array<CauseAction>;
    "blocked"?: boolean;
    "buildable"?: boolean;
    "id"?: number;
    "inQueueSince"?: number;
    "params"?: string;
    "stuck"?: boolean;
    "task"?: FreeStyleProject;
    "url"?: string;
    "why"?: string;
    "buildableStartMilliseconds"?: number;
}

export interface QueueItemImpl {
    "class"?: string;
    "expectedBuildNumber"?: number;
    "id"?: string;
    "pipeline"?: string;
    "queuedTime"?: number;
}

export interface QueueLeftItem {
    "class"?: string;
    "actions"?: Array<CauseAction>;
    "blocked"?: boolean;
    "buildable"?: boolean;
    "id"?: number;
    "inQueueSince"?: number;
    "params"?: string;
    "stuck"?: boolean;
    "task"?: FreeStyleProject;
    "url"?: string;
    "why"?: string;
    "cancelled"?: boolean;
    "executable"?: FreeStyleBuild;
}

export interface ResponseTimeMonitorData {
    "class"?: string;
    "timestamp"?: number;
    "average"?: number;
}

export interface ScmOrganisations extends Array<GithubOrganization> {
}

export interface StringParameterDefinition {
    "class"?: string;
    "defaultParameterValue"?: StringParameterValue;
    "description"?: string;
    "name"?: string;
    "type"?: string;
}

export interface StringParameterValue {
    "class"?: string;
    "name"?: string;
    "value"?: string;
}

export interface SwapSpaceMonitorMemoryUsage2 {
    "class"?: string;
    "availablePhysicalMemory"?: number;
    "availableSwapSpace"?: number;
    "totalPhysicalMemory"?: number;
    "totalSwapSpace"?: number;
}

export interface UnlabeledLoadStatistics {
    "class"?: string;
}

export interface User {
    "class"?: string;
    "id"?: string;
    "fullName"?: string;
    "email"?: string;
    "name"?: string;
}

export interface UserFavorites extends Array<FavoriteImpl> {
}

export interface Users extends Array<User> {
}



/**
 * BlueOceanApi - fetch parameter creator
 */
export const BlueOceanApiFetchParamCreator = {
    /**
     * Delete queue item from an organization pipeline queue
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     */
    deletePipelineQueueItem(params: {  organization: string; pipeline: string; queue: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling deletePipelineQueueItem");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling deletePipelineQueueItem");
        }
        // verify required parameter "queue" is set
        if (params["queue"] == null) {
            throw new Error("Missing required parameter queue when calling deletePipelineQueueItem");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue/{queue}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"queue"}}`, `${ params["queue"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve authenticated user details for an organization
     * @param organization Name of the organization
     */
    getAuthenticatedUser(params: {  organization: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getAuthenticatedUser");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/user/`
            .replace(`{${"organization"}}`, `${ params["organization"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    getClasses(params: {  _class: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "_class" is set
        if (params["_class"] == null) {
            throw new Error("Missing required parameter _class when calling getClasses");
        }
        const baseUrl = `/blue/rest/classes/{class}`
            .replace(`{${"class"}}`, `${ params["_class"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve organization details
     * @param organization Name of the organization
     */
    getOrganisation(params: {  organization: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getOrganisation");
        }
        const baseUrl = `/blue/rest/organizations/{organization}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve all organizations details
     */
    getOrganisations(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/blue/rest/organizations/`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve pipeline details for an organization
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipeline(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipeline");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipeline");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve all activities details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineActivities(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineActivities");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineActivities");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/activities`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve branch details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    getPipelineBranch(params: {  organization: string; pipeline: string; branch: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineBranch");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineBranch");
        }
        // verify required parameter "branch" is set
        if (params["branch"] == null) {
            throw new Error("Missing required parameter branch when calling getPipelineBranch");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"branch"}}`, `${ params["branch"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve branch run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     */
    getPipelineBranchRun(params: {  organization: string; pipeline: string; branch: string; run: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineBranchRun");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineBranchRun");
        }
        // verify required parameter "branch" is set
        if (params["branch"] == null) {
            throw new Error("Missing required parameter branch when calling getPipelineBranchRun");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineBranchRun");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches/{branch}/runs/{run}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"branch"}}`, `${ params["branch"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve all branches details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineBranches(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineBranches");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineBranches");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/branches`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve pipeline folder for an organization
     * @param organization Name of the organization
     * @param folder Name of the folder
     */
    getPipelineFolder(params: {  organization: string; folder: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineFolder");
        }
        // verify required parameter "folder" is set
        if (params["folder"] == null) {
            throw new Error("Missing required parameter folder when calling getPipelineFolder");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{folder}/`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"folder"}}`, `${ params["folder"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve pipeline details for an organization folder
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    getPipelineFolderPipeline(params: {  organization: string; pipeline: string; folder: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineFolderPipeline");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineFolderPipeline");
        }
        // verify required parameter "folder" is set
        if (params["folder"] == null) {
            throw new Error("Missing required parameter folder when calling getPipelineFolderPipeline");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{folder}/pipelines/{pipeline}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"folder"}}`, `${ params["folder"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve queue details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineQueue(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineQueue");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineQueue");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/queue`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    getPipelineRun(params: {  organization: string; pipeline: string; run: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRun");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRun");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRun");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get log for a pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body
     */
    getPipelineRunLog(params: {  organization: string; pipeline: string; run: string; start?: number; download?: boolean; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRunLog");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRunLog");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRunLog");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/log`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["start"] !== undefined) {
            urlObj.query["start"] = params["start"];
        }
        if (params["download"] !== undefined) {
            urlObj.query["download"] = params["download"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    getPipelineRunNode(params: {  organization: string; pipeline: string; run: string; node: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRunNode");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRunNode");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRunNode");
        }
        // verify required parameter "node" is set
        if (params["node"] == null) {
            throw new Error("Missing required parameter node when calling getPipelineRunNode");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`)
            .replace(`{${"node"}}`, `${ params["node"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    getPipelineRunNodeStep(params: {  organization: string; pipeline: string; run: string; node: string; step: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRunNodeStep");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRunNodeStep");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRunNodeStep");
        }
        // verify required parameter "node" is set
        if (params["node"] == null) {
            throw new Error("Missing required parameter node when calling getPipelineRunNodeStep");
        }
        // verify required parameter "step" is set
        if (params["step"] == null) {
            throw new Error("Missing required parameter step when calling getPipelineRunNodeStep");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`)
            .replace(`{${"node"}}`, `${ params["node"] }`)
            .replace(`{${"step"}}`, `${ params["step"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get log for a pipeline run node step
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    getPipelineRunNodeStepLog(params: {  organization: string; pipeline: string; run: string; node: string; step: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRunNodeStepLog");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRunNodeStepLog");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRunNodeStepLog");
        }
        // verify required parameter "node" is set
        if (params["node"] == null) {
            throw new Error("Missing required parameter node when calling getPipelineRunNodeStepLog");
        }
        // verify required parameter "step" is set
        if (params["step"] == null) {
            throw new Error("Missing required parameter step when calling getPipelineRunNodeStepLog");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps/{step}/log`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`)
            .replace(`{${"node"}}`, `${ params["node"] }`)
            .replace(`{${"step"}}`, `${ params["step"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve run node steps details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    getPipelineRunNodeSteps(params: {  organization: string; pipeline: string; run: string; node: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRunNodeSteps");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRunNodeSteps");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRunNodeSteps");
        }
        // verify required parameter "node" is set
        if (params["node"] == null) {
            throw new Error("Missing required parameter node when calling getPipelineRunNodeSteps");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes/{node}/steps`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`)
            .replace(`{${"node"}}`, `${ params["node"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve run nodes details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    getPipelineRunNodes(params: {  organization: string; pipeline: string; run: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRunNodes");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRunNodes");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling getPipelineRunNodes");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/nodes`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve all runs details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineRuns(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelineRuns");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling getPipelineRuns");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve all pipelines details for an organization
     * @param organization Name of the organization
     */
    getPipelines(params: {  organization: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getPipelines");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/`
            .replace(`{${"organization"}}`, `${ params["organization"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve SCM details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     */
    getSCM(params: {  organization: string; scm: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getSCM");
        }
        // verify required parameter "scm" is set
        if (params["scm"] == null) {
            throw new Error("Missing required parameter scm when calling getSCM");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/scm/{scm}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"scm"}}`, `${ params["scm"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve SCM organization repositories details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID
     * @param pageSize Number of items in a page
     * @param pageNumber Page number
     */
    getSCMOrganisationRepositories(params: {  organization: string; scm: string; scmOrganisation: string; credentialId?: string; pageSize?: number; pageNumber?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getSCMOrganisationRepositories");
        }
        // verify required parameter "scm" is set
        if (params["scm"] == null) {
            throw new Error("Missing required parameter scm when calling getSCMOrganisationRepositories");
        }
        // verify required parameter "scmOrganisation" is set
        if (params["scmOrganisation"] == null) {
            throw new Error("Missing required parameter scmOrganisation when calling getSCMOrganisationRepositories");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"scm"}}`, `${ params["scm"] }`)
            .replace(`{${"scmOrganisation"}}`, `${ params["scmOrganisation"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["credentialId"] !== undefined) {
            urlObj.query["credentialId"] = params["credentialId"];
        }
        if (params["pageSize"] !== undefined) {
            urlObj.query["pageSize"] = params["pageSize"];
        }
        if (params["pageNumber"] !== undefined) {
            urlObj.query["pageNumber"] = params["pageNumber"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve SCM organization repository details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID
     */
    getSCMOrganisationRepository(params: {  organization: string; scm: string; scmOrganisation: string; repository: string; credentialId?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getSCMOrganisationRepository");
        }
        // verify required parameter "scm" is set
        if (params["scm"] == null) {
            throw new Error("Missing required parameter scm when calling getSCMOrganisationRepository");
        }
        // verify required parameter "scmOrganisation" is set
        if (params["scmOrganisation"] == null) {
            throw new Error("Missing required parameter scmOrganisation when calling getSCMOrganisationRepository");
        }
        // verify required parameter "repository" is set
        if (params["repository"] == null) {
            throw new Error("Missing required parameter repository when calling getSCMOrganisationRepository");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/scm/{scm}/organizations/{scmOrganisation}/repositories/{repository}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"scm"}}`, `${ params["scm"] }`)
            .replace(`{${"scmOrganisation"}}`, `${ params["scmOrganisation"] }`)
            .replace(`{${"repository"}}`, `${ params["repository"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["credentialId"] !== undefined) {
            urlObj.query["credentialId"] = params["credentialId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve SCM organizations details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID
     */
    getSCMOrganisations(params: {  organization: string; scm: string; credentialId?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getSCMOrganisations");
        }
        // verify required parameter "scm" is set
        if (params["scm"] == null) {
            throw new Error("Missing required parameter scm when calling getSCMOrganisations");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/scm/{scm}/organizations`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"scm"}}`, `${ params["scm"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["credentialId"] !== undefined) {
            urlObj.query["credentialId"] = params["credentialId"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve user details for an organization
     * @param organization Name of the organization
     * @param user Name of the user
     */
    getUser(params: {  organization: string; user: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getUser");
        }
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling getUser");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/users/{user}`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"user"}}`, `${ params["user"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve user favorites details for an organization
     * @param user Name of the user
     */
    getUserFavorites(params: {  user: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling getUserFavorites");
        }
        const baseUrl = `/blue/rest/users/{user}/favorites`
            .replace(`{${"user"}}`, `${ params["user"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve users details for an organization
     * @param organization Name of the organization
     */
    getUsers(params: {  organization: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling getUsers");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/users/`
            .replace(`{${"organization"}}`, `${ params["organization"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Replay an organization pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    postPipelineRun(params: {  organization: string; pipeline: string; run: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling postPipelineRun");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling postPipelineRun");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling postPipelineRun");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/replay`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Start a build for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    postPipelineRuns(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling postPipelineRuns");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling postPipelineRuns");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Favorite/unfavorite a pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     */
    putPipelineFavorite(params: {  organization: string; pipeline: string; body: Body; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling putPipelineFavorite");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling putPipelineFavorite");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling putPipelineFavorite");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/favorite`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Stop a build of an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds
     */
    putPipelineRun(params: {  organization: string; pipeline: string; run: string; blocking?: string; timeOutInSecs?: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "organization" is set
        if (params["organization"] == null) {
            throw new Error("Missing required parameter organization when calling putPipelineRun");
        }
        // verify required parameter "pipeline" is set
        if (params["pipeline"] == null) {
            throw new Error("Missing required parameter pipeline when calling putPipelineRun");
        }
        // verify required parameter "run" is set
        if (params["run"] == null) {
            throw new Error("Missing required parameter run when calling putPipelineRun");
        }
        const baseUrl = `/blue/rest/organizations/{organization}/pipelines/{pipeline}/runs/{run}/stop`
            .replace(`{${"organization"}}`, `${ params["organization"] }`)
            .replace(`{${"pipeline"}}`, `${ params["pipeline"] }`)
            .replace(`{${"run"}}`, `${ params["run"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["blocking"] !== undefined) {
            urlObj.query["blocking"] = params["blocking"];
        }
        if (params["timeOutInSecs"] !== undefined) {
            urlObj.query["timeOutInSecs"] = params["timeOutInSecs"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Search for any resource details
     * @param q Query string
     */
    search(params: {  q: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "q" is set
        if (params["q"] == null) {
            throw new Error("Missing required parameter q when calling search");
        }
        const baseUrl = `/blue/rest/search/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Get classes details
     * @param q Query string containing an array of class names
     */
    searchClasses(params: {  q: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "q" is set
        if (params["q"] == null) {
            throw new Error("Missing required parameter q when calling searchClasses");
        }
        const baseUrl = `/blue/rest/classes/`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["q"] !== undefined) {
            urlObj.query["q"] = params["q"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BlueOceanApi - functional programming interface
 */
export const BlueOceanApiFp = {
    /**
     * Delete queue item from an organization pipeline queue
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     */
    deletePipelineQueueItem(params: { organization: string; pipeline: string; queue: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BlueOceanApiFetchParamCreator.deletePipelineQueueItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve authenticated user details for an organization
     * @param organization Name of the organization
     */
    getAuthenticatedUser(params: { organization: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getAuthenticatedUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    getClasses(params: { _class: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getClasses(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve organization details
     * @param organization Name of the organization
     */
    getOrganisation(params: { organization: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Organisation> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getOrganisation(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve all organizations details
     */
    getOrganisations(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Organisations> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getOrganisations(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve pipeline details for an organization
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipeline(params: { organization: string; pipeline: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Pipeline> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipeline(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve all activities details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineActivities(params: { organization: string; pipeline: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineActivities> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineActivities(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve branch details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    getPipelineBranch(params: { organization: string; pipeline: string; branch: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<BranchImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineBranch(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve branch run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     */
    getPipelineBranchRun(params: { organization: string; pipeline: string; branch: string; run: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRun> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineBranchRun(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve all branches details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineBranches(params: { organization: string; pipeline: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<MultibranchPipeline> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineBranches(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve pipeline folder for an organization
     * @param organization Name of the organization
     * @param folder Name of the folder
     */
    getPipelineFolder(params: { organization: string; folder: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineFolderImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineFolder(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve pipeline details for an organization folder
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    getPipelineFolderPipeline(params: { organization: string; pipeline: string; folder: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineFolderPipeline(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve queue details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineQueue(params: { organization: string; pipeline: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineQueue> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineQueue(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    getPipelineRun(params: { organization: string; pipeline: string; run: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRun> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRun(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get log for a pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body
     */
    getPipelineRunLog(params: { organization: string; pipeline: string; run: string; start?: number; download?: boolean;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRunLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    getPipelineRunNode(params: { organization: string; pipeline: string; run: string; node: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRunNode> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRunNode(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    getPipelineRunNodeStep(params: { organization: string; pipeline: string; run: string; node: string; step: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineStepImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRunNodeStep(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get log for a pipeline run node step
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    getPipelineRunNodeStepLog(params: { organization: string; pipeline: string; run: string; node: string; step: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRunNodeStepLog(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve run node steps details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    getPipelineRunNodeSteps(params: { organization: string; pipeline: string; run: string; node: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRunNodeSteps> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRunNodeSteps(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve run nodes details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    getPipelineRunNodes(params: { organization: string; pipeline: string; run: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRunNodes> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRunNodes(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve all runs details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineRuns(params: { organization: string; pipeline: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRuns> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelineRuns(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve all pipelines details for an organization
     * @param organization Name of the organization
     */
    getPipelines(params: { organization: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Pipelines> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getPipelines(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve SCM details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     */
    getSCM(params: { organization: string; scm: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<GithubScm> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getSCM(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve SCM organization repositories details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID
     * @param pageSize Number of items in a page
     * @param pageNumber Page number
     */
    getSCMOrganisationRepositories(params: { organization: string; scm: string; scmOrganisation: string; credentialId?: string; pageSize?: number; pageNumber?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ScmOrganisations> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getSCMOrganisationRepositories(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve SCM organization repository details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID
     */
    getSCMOrganisationRepository(params: { organization: string; scm: string; scmOrganisation: string; repository: string; credentialId?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ScmOrganisations> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getSCMOrganisationRepository(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve SCM organizations details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID
     */
    getSCMOrganisations(params: { organization: string; scm: string; credentialId?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ScmOrganisations> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getSCMOrganisations(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve user details for an organization
     * @param organization Name of the organization
     * @param user Name of the user
     */
    getUser(params: { organization: string; user: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getUser(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve user favorites details for an organization
     * @param user Name of the user
     */
    getUserFavorites(params: { user: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<UserFavorites> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getUserFavorites(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve users details for an organization
     * @param organization Name of the organization
     */
    getUsers(params: { organization: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = BlueOceanApiFetchParamCreator.getUsers(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Replay an organization pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    postPipelineRun(params: { organization: string; pipeline: string; run: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QueueItemImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.postPipelineRun(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Start a build for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    postPipelineRuns(params: { organization: string; pipeline: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<QueueItemImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.postPipelineRuns(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Favorite/unfavorite a pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     */
    putPipelineFavorite(params: { organization: string; pipeline: string; body: Body;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FavoriteImpl> {
        const fetchArgs = BlueOceanApiFetchParamCreator.putPipelineFavorite(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Stop a build of an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds
     */
    putPipelineRun(params: { organization: string; pipeline: string; run: string; blocking?: string; timeOutInSecs?: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<PipelineRun> {
        const fetchArgs = BlueOceanApiFetchParamCreator.putPipelineRun(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Search for any resource details
     * @param q Query string
     */
    search(params: { q: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.search(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Get classes details
     * @param q Query string containing an array of class names
     */
    searchClasses(params: { q: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = BlueOceanApiFetchParamCreator.searchClasses(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BlueOceanApi - object-oriented interface
 */
export class BlueOceanApi extends BaseAPI {
    /**
     * Delete queue item from an organization pipeline queue
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param queue Name of the queue item
     */
    deletePipelineQueueItem(params: {  organization: string; pipeline: string; queue: string; }, options: any = {}) {
        return BlueOceanApiFp.deletePipelineQueueItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve authenticated user details for an organization
     * @param organization Name of the organization
     */
    getAuthenticatedUser(params: {  organization: string; }, options: any = {}) {
        return BlueOceanApiFp.getAuthenticatedUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    getClasses(params: {  _class: string; }, options: any = {}) {
        return BlueOceanApiFp.getClasses(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve organization details
     * @param organization Name of the organization
     */
    getOrganisation(params: {  organization: string; }, options: any = {}) {
        return BlueOceanApiFp.getOrganisation(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all organizations details
     */
    getOrganisations(options: any = {}) {
        return BlueOceanApiFp.getOrganisations(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve pipeline details for an organization
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipeline(params: {  organization: string; pipeline: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipeline(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all activities details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineActivities(params: {  organization: string; pipeline: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineActivities(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve branch details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    getPipelineBranch(params: {  organization: string; pipeline: string; branch: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineBranch(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve branch run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     * @param run Name of the run
     */
    getPipelineBranchRun(params: {  organization: string; pipeline: string; branch: string; run: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineBranchRun(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all branches details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineBranches(params: {  organization: string; pipeline: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineBranches(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve pipeline folder for an organization
     * @param organization Name of the organization
     * @param folder Name of the folder
     */
    getPipelineFolder(params: {  organization: string; folder: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineFolder(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve pipeline details for an organization folder
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    getPipelineFolderPipeline(params: {  organization: string; pipeline: string; folder: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineFolderPipeline(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve queue details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineQueue(params: {  organization: string; pipeline: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineQueue(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve run details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    getPipelineRun(params: {  organization: string; pipeline: string; run: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRun(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get log for a pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param start Start position of the log
     * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body
     */
    getPipelineRunLog(params: {  organization: string; pipeline: string; run: string; start?: number; download?: boolean; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRunLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    getPipelineRunNode(params: {  organization: string; pipeline: string; run: string; node: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRunNode(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve run node details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    getPipelineRunNodeStep(params: {  organization: string; pipeline: string; run: string; node: string; step: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRunNodeStep(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get log for a pipeline run node step
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     * @param step Name of the step
     */
    getPipelineRunNodeStepLog(params: {  organization: string; pipeline: string; run: string; node: string; step: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRunNodeStepLog(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve run node steps details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param node Name of the node
     */
    getPipelineRunNodeSteps(params: {  organization: string; pipeline: string; run: string; node: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRunNodeSteps(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve run nodes details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    getPipelineRunNodes(params: {  organization: string; pipeline: string; run: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRunNodes(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all runs details for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    getPipelineRuns(params: {  organization: string; pipeline: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelineRuns(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve all pipelines details for an organization
     * @param organization Name of the organization
     */
    getPipelines(params: {  organization: string; }, options: any = {}) {
        return BlueOceanApiFp.getPipelines(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve SCM details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     */
    getSCM(params: {  organization: string; scm: string; }, options: any = {}) {
        return BlueOceanApiFp.getSCM(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve SCM organization repositories details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param credentialId Credential ID
     * @param pageSize Number of items in a page
     * @param pageNumber Page number
     */
    getSCMOrganisationRepositories(params: {  organization: string; scm: string; scmOrganisation: string; credentialId?: string; pageSize?: number; pageNumber?: number; }, options: any = {}) {
        return BlueOceanApiFp.getSCMOrganisationRepositories(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve SCM organization repository details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param scmOrganisation Name of the SCM organization
     * @param repository Name of the SCM repository
     * @param credentialId Credential ID
     */
    getSCMOrganisationRepository(params: {  organization: string; scm: string; scmOrganisation: string; repository: string; credentialId?: string; }, options: any = {}) {
        return BlueOceanApiFp.getSCMOrganisationRepository(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve SCM organizations details for an organization
     * @param organization Name of the organization
     * @param scm Name of SCM
     * @param credentialId Credential ID
     */
    getSCMOrganisations(params: {  organization: string; scm: string; credentialId?: string; }, options: any = {}) {
        return BlueOceanApiFp.getSCMOrganisations(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve user details for an organization
     * @param organization Name of the organization
     * @param user Name of the user
     */
    getUser(params: {  organization: string; user: string; }, options: any = {}) {
        return BlueOceanApiFp.getUser(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve user favorites details for an organization
     * @param user Name of the user
     */
    getUserFavorites(params: {  user: string; }, options: any = {}) {
        return BlueOceanApiFp.getUserFavorites(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve users details for an organization
     * @param organization Name of the organization
     */
    getUsers(params: {  organization: string; }, options: any = {}) {
        return BlueOceanApiFp.getUsers(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Replay an organization pipeline run
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     */
    postPipelineRun(params: {  organization: string; pipeline: string; run: string; }, options: any = {}) {
        return BlueOceanApiFp.postPipelineRun(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Start a build for an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     */
    postPipelineRuns(params: {  organization: string; pipeline: string; }, options: any = {}) {
        return BlueOceanApiFp.postPipelineRuns(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Favorite/unfavorite a pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
     */
    putPipelineFavorite(params: {  organization: string; pipeline: string; body: Body; }, options: any = {}) {
        return BlueOceanApiFp.putPipelineFavorite(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Stop a build of an organization pipeline
     * @param organization Name of the organization
     * @param pipeline Name of the pipeline
     * @param run Name of the run
     * @param blocking Set to true to make blocking stop, default: false
     * @param timeOutInSecs Timeout in seconds, default: 10 seconds
     */
    putPipelineRun(params: {  organization: string; pipeline: string; run: string; blocking?: string; timeOutInSecs?: number; }, options: any = {}) {
        return BlueOceanApiFp.putPipelineRun(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Search for any resource details
     * @param q Query string
     */
    search(params: {  q: string; }, options: any = {}) {
        return BlueOceanApiFp.search(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Get classes details
     * @param q Query string containing an array of class names
     */
    searchClasses(params: {  q: string; }, options: any = {}) {
        return BlueOceanApiFp.searchClasses(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * BlueOceanApi - factory interface
 */
export const BlueOceanApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete queue item from an organization pipeline queue
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param queue Name of the queue item
         */
        deletePipelineQueueItem(params: {  organization: string; pipeline: string; queue: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.deletePipelineQueueItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve authenticated user details for an organization
         * @param organization Name of the organization
         */
        getAuthenticatedUser(params: {  organization: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getAuthenticatedUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get a list of class names supported by a given class
         * @param _class Name of the class
         */
        getClasses(params: {  _class: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getClasses(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve organization details
         * @param organization Name of the organization
         */
        getOrganisation(params: {  organization: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getOrganisation(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve all organizations details
         */
        getOrganisations(configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getOrganisations(configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve pipeline details for an organization
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         */
        getPipeline(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipeline(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve all activities details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         */
        getPipelineActivities(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineActivities(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve branch details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param branch Name of the branch
         */
        getPipelineBranch(params: {  organization: string; pipeline: string; branch: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineBranch(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve branch run details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param branch Name of the branch
         * @param run Name of the run
         */
        getPipelineBranchRun(params: {  organization: string; pipeline: string; branch: string; run: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineBranchRun(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve all branches details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         */
        getPipelineBranches(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineBranches(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve pipeline folder for an organization
         * @param organization Name of the organization
         * @param folder Name of the folder
         */
        getPipelineFolder(params: {  organization: string; folder: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineFolder(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve pipeline details for an organization folder
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param folder Name of the folder
         */
        getPipelineFolderPipeline(params: {  organization: string; pipeline: string; folder: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineFolderPipeline(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve queue details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         */
        getPipelineQueue(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineQueue(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve run details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         */
        getPipelineRun(params: {  organization: string; pipeline: string; run: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRun(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get log for a pipeline run
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         * @param start Start position of the log
         * @param download Set to true in order to download the file, otherwise it&#39;s passed as a response body
         */
        getPipelineRunLog(params: {  organization: string; pipeline: string; run: string; start?: number; download?: boolean; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRunLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         * @param node Name of the node
         */
        getPipelineRunNode(params: {  organization: string; pipeline: string; run: string; node: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRunNode(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve run node details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         * @param node Name of the node
         * @param step Name of the step
         */
        getPipelineRunNodeStep(params: {  organization: string; pipeline: string; run: string; node: string; step: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRunNodeStep(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get log for a pipeline run node step
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         * @param node Name of the node
         * @param step Name of the step
         */
        getPipelineRunNodeStepLog(params: {  organization: string; pipeline: string; run: string; node: string; step: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRunNodeStepLog(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve run node steps details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         * @param node Name of the node
         */
        getPipelineRunNodeSteps(params: {  organization: string; pipeline: string; run: string; node: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRunNodeSteps(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve run nodes details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         */
        getPipelineRunNodes(params: {  organization: string; pipeline: string; run: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRunNodes(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve all runs details for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         */
        getPipelineRuns(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelineRuns(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve all pipelines details for an organization
         * @param organization Name of the organization
         */
        getPipelines(params: {  organization: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getPipelines(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM details for an organization
         * @param organization Name of the organization
         * @param scm Name of SCM
         */
        getSCM(params: {  organization: string; scm: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getSCM(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM organization repositories details for an organization
         * @param organization Name of the organization
         * @param scm Name of SCM
         * @param scmOrganisation Name of the SCM organization
         * @param credentialId Credential ID
         * @param pageSize Number of items in a page
         * @param pageNumber Page number
         */
        getSCMOrganisationRepositories(params: {  organization: string; scm: string; scmOrganisation: string; credentialId?: string; pageSize?: number; pageNumber?: number; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getSCMOrganisationRepositories(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM organization repository details for an organization
         * @param organization Name of the organization
         * @param scm Name of SCM
         * @param scmOrganisation Name of the SCM organization
         * @param repository Name of the SCM repository
         * @param credentialId Credential ID
         */
        getSCMOrganisationRepository(params: {  organization: string; scm: string; scmOrganisation: string; repository: string; credentialId?: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getSCMOrganisationRepository(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve SCM organizations details for an organization
         * @param organization Name of the organization
         * @param scm Name of SCM
         * @param credentialId Credential ID
         */
        getSCMOrganisations(params: {  organization: string; scm: string; credentialId?: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getSCMOrganisations(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve user details for an organization
         * @param organization Name of the organization
         * @param user Name of the user
         */
        getUser(params: {  organization: string; user: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getUser(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve user favorites details for an organization
         * @param user Name of the user
         */
        getUserFavorites(params: {  user: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getUserFavorites(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve users details for an organization
         * @param organization Name of the organization
         */
        getUsers(params: {  organization: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.getUsers(params, configuration, options)(fetch, basePath);
        },
        /**
         * Replay an organization pipeline run
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         */
        postPipelineRun(params: {  organization: string; pipeline: string; run: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.postPipelineRun(params, configuration, options)(fetch, basePath);
        },
        /**
         * Start a build for an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         */
        postPipelineRuns(params: {  organization: string; pipeline: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.postPipelineRuns(params, configuration, options)(fetch, basePath);
        },
        /**
         * Favorite/unfavorite a pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param body Set JSON string body to {\&quot;favorite\&quot;: true} to favorite, set value to false to unfavorite
         */
        putPipelineFavorite(params: {  organization: string; pipeline: string; body: Body; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.putPipelineFavorite(params, configuration, options)(fetch, basePath);
        },
        /**
         * Stop a build of an organization pipeline
         * @param organization Name of the organization
         * @param pipeline Name of the pipeline
         * @param run Name of the run
         * @param blocking Set to true to make blocking stop, default: false
         * @param timeOutInSecs Timeout in seconds, default: 10 seconds
         */
        putPipelineRun(params: {  organization: string; pipeline: string; run: string; blocking?: string; timeOutInSecs?: number; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.putPipelineRun(params, configuration, options)(fetch, basePath);
        },
        /**
         * Search for any resource details
         * @param q Query string
         */
        search(params: {  q: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.search(params, configuration, options)(fetch, basePath);
        },
        /**
         * Get classes details
         * @param q Query string containing an array of class names
         */
        searchClasses(params: {  q: string; }, configuration: Configuration, options: any = {}) {
            return BlueOceanApiFp.searchClasses(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * RemoteAccessApi - fetch parameter creator
 */
export const RemoteAccessApiFetchParamCreator = {
    /**
     * Retrieve computer details
     * @param depth Recursion depth in response model
     */
    getComputer(params: {  depth: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "depth" is set
        if (params["depth"] == null) {
            throw new Error("Missing required parameter depth when calling getComputer");
        }
        const baseUrl = `/computer/api/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["depth"] !== undefined) {
            urlObj.query["depth"] = params["depth"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve CSRF protection token
     */
    getCrumb(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/crumbIssuer/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve Jenkins details
     */
    getJenkins(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve job details
     * @param name Name of the job
     */
    getJob(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJob");
        }
        const baseUrl = `/job/{name}/api/json`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve job configuration
     * @param name Name of the job
     */
    getJobConfig(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJobConfig");
        }
        const baseUrl = `/job/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve job's last build details
     * @param name Name of the job
     */
    getJobLastBuild(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJobLastBuild");
        }
        const baseUrl = `/job/{name}/lastBuild/api/json`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve job's build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    getJobProgressiveText(params: {  name: string; number: string; start: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getJobProgressiveText");
        }
        // verify required parameter "number" is set
        if (params["number"] == null) {
            throw new Error("Missing required parameter number when calling getJobProgressiveText");
        }
        // verify required parameter "start" is set
        if (params["start"] == null) {
            throw new Error("Missing required parameter start when calling getJobProgressiveText");
        }
        const baseUrl = `/job/{name}/{number}/logText/progressiveText`
            .replace(`{${"name"}}`, `${ params["name"] }`)
            .replace(`{${"number"}}`, `${ params["number"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["start"] !== undefined) {
            urlObj.query["start"] = params["start"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve queue details
     */
    getQueue(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/queue/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve queued item details
     * @param number Queue number
     */
    getQueueItem(params: {  number: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "number" is set
        if (params["number"] == null) {
            throw new Error("Missing required parameter number when calling getQueueItem");
        }
        const baseUrl = `/queue/item/{number}/api/json`
            .replace(`{${"number"}}`, `${ params["number"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve view details
     * @param name Name of the view
     */
    getView(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getView");
        }
        const baseUrl = `/view/{name}/api/json`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve view configuration
     * @param name Name of the view
     */
    getViewConfig(params: {  name: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling getViewConfig");
        }
        const baseUrl = `/view/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Retrieve Jenkins headers
     */
    headJenkins(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/api/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateItem(params: {  name: string; from?: string; mode?: string; body?: string; jenkinsCrumb?: string; contentType?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postCreateItem");
        }
        const baseUrl = `/createItem`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        if (params["from"] !== undefined) {
            urlObj.query["from"] = params["from"];
        }
        if (params["mode"] !== undefined) {
            urlObj.query["mode"] = params["mode"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],"Content-Type": params["contentType"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateView(params: {  name: string; body?: string; jenkinsCrumb?: string; contentType?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postCreateView");
        }
        const baseUrl = `/createView`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["name"] !== undefined) {
            urlObj.query["name"] = params["name"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],"Content-Type": params["contentType"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    postJobBuild(params: {  name: string; json: string; token?: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobBuild");
        }
        // verify required parameter "json" is set
        if (params["json"] == null) {
            throw new Error("Missing required parameter json when calling postJobBuild");
        }
        const baseUrl = `/job/{name}/build`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["json"] !== undefined) {
            urlObj.query["json"] = params["json"];
        }
        if (params["token"] !== undefined) {
            urlObj.query["token"] = params["token"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postJobConfig(params: {  name: string; body: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobConfig");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling postJobConfig");
        }
        const baseUrl = `/job/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDelete(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobDelete");
        }
        const baseUrl = `/job/{name}/doDelete`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDisable(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobDisable");
        }
        const baseUrl = `/job/{name}/disable`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobEnable(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobEnable");
        }
        const baseUrl = `/job/{name}/enable`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobLastBuildStop(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postJobLastBuildStop");
        }
        const baseUrl = `/job/{name}/lastBuild/stop`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postViewConfig(params: {  name: string; body: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "name" is set
        if (params["name"] == null) {
            throw new Error("Missing required parameter name when calling postViewConfig");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling postViewConfig");
        }
        const baseUrl = `/view/{name}/config.xml`
            .replace(`{${"name"}}`, `${ params["name"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        fetchOptions.headers = assign({
            "Jenkins-Crumb": params["jenkinsCrumb"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (jenkins_auth) required
        // http basic authentication required
        if (configuration.username || configuration.password) {
            fetchOptions.headers = assign({
                    "Authorization": "Basic " + btoa(configuration.username + ":" + configuration.password),
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * RemoteAccessApi - functional programming interface
 */
export const RemoteAccessApiFp = {
    /**
     * Retrieve computer details
     * @param depth Recursion depth in response model
     */
    getComputer(params: { depth: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ComputerSet> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getComputer(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve CSRF protection token
     */
    getCrumb(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<DefaultCrumbIssuer> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getCrumb(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve Jenkins details
     */
    getJenkins(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Hudson> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJenkins(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve job details
     * @param name Name of the job
     */
    getJob(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FreeStyleProject> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJob(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve job configuration
     * @param name Name of the job
     */
    getJobConfig(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJobConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve job's last build details
     * @param name Name of the job
     */
    getJobLastBuild(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<FreeStyleBuild> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJobLastBuild(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve job's build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    getJobProgressiveText(params: { name: string; number: string; start: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getJobProgressiveText(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve queue details
     */
    getQueue(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Queue> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getQueue(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve queued item details
     * @param number Queue number
     */
    getQueueItem(params: { number: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Queue> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getQueueItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve view details
     * @param name Name of the view
     */
    getView(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ListView> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getView(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve view configuration
     * @param name Name of the view
     */
    getViewConfig(params: { name: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.getViewConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Retrieve Jenkins headers
     */
    headJenkins(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.headJenkins(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateItem(params: { name: string; from?: string; mode?: string; body?: string; jenkinsCrumb?: string; contentType?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postCreateItem(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateView(params: { name: string; body?: string; jenkinsCrumb?: string; contentType?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postCreateView(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    postJobBuild(params: { name: string; json: string; token?: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobBuild(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postJobConfig(params: { name: string; body: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDelete(params: { name: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobDelete(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDisable(params: { name: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobDisable(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobEnable(params: { name: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobEnable(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobLastBuildStop(params: { name: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postJobLastBuildStop(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postViewConfig(params: { name: string; body: string; jenkinsCrumb?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = RemoteAccessApiFetchParamCreator.postViewConfig(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * RemoteAccessApi - object-oriented interface
 */
export class RemoteAccessApi extends BaseAPI {
    /**
     * Retrieve computer details
     * @param depth Recursion depth in response model
     */
    getComputer(params: {  depth: number; }, options: any = {}) {
        return RemoteAccessApiFp.getComputer(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve CSRF protection token
     */
    getCrumb(options: any = {}) {
        return RemoteAccessApiFp.getCrumb(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve Jenkins details
     */
    getJenkins(options: any = {}) {
        return RemoteAccessApiFp.getJenkins(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve job details
     * @param name Name of the job
     */
    getJob(params: {  name: string; }, options: any = {}) {
        return RemoteAccessApiFp.getJob(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve job configuration
     * @param name Name of the job
     */
    getJobConfig(params: {  name: string; }, options: any = {}) {
        return RemoteAccessApiFp.getJobConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve job's last build details
     * @param name Name of the job
     */
    getJobLastBuild(params: {  name: string; }, options: any = {}) {
        return RemoteAccessApiFp.getJobLastBuild(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve job's build progressive text output
     * @param name Name of the job
     * @param number Build number
     * @param start Starting point of progressive text output
     */
    getJobProgressiveText(params: {  name: string; number: string; start: string; }, options: any = {}) {
        return RemoteAccessApiFp.getJobProgressiveText(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve queue details
     */
    getQueue(options: any = {}) {
        return RemoteAccessApiFp.getQueue(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve queued item details
     * @param number Queue number
     */
    getQueueItem(params: {  number: string; }, options: any = {}) {
        return RemoteAccessApiFp.getQueueItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve view details
     * @param name Name of the view
     */
    getView(params: {  name: string; }, options: any = {}) {
        return RemoteAccessApiFp.getView(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve view configuration
     * @param name Name of the view
     */
    getViewConfig(params: {  name: string; }, options: any = {}) {
        return RemoteAccessApiFp.getViewConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Retrieve Jenkins headers
     */
    headJenkins(options: any = {}) {
        return RemoteAccessApiFp.headJenkins(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new job using job configuration, or copied from an existing job
     * @param name Name of the new job
     * @param from Existing job to copy from
     * @param mode Set to &#39;copy&#39; for copying an existing job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateItem(params: {  name: string; from?: string; mode?: string; body?: string; jenkinsCrumb?: string; contentType?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postCreateItem(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new view using view configuration
     * @param name Name of the new view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     * @param contentType Content type header application/xml
     */
    postCreateView(params: {  name: string; body?: string; jenkinsCrumb?: string; contentType?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postCreateView(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Build a job
     * @param name Name of the job
     * @param json 
     * @param token 
     * @param jenkinsCrumb CSRF protection token
     */
    postJobBuild(params: {  name: string; json: string; token?: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postJobBuild(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Update job configuration
     * @param name Name of the job
     * @param body Job configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postJobConfig(params: {  name: string; body: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postJobConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Delete a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDelete(params: {  name: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postJobDelete(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Disable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobDisable(params: {  name: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postJobDisable(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Enable a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobEnable(params: {  name: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postJobEnable(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Stop a job
     * @param name Name of the job
     * @param jenkinsCrumb CSRF protection token
     */
    postJobLastBuildStop(params: {  name: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postJobLastBuildStop(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Update view configuration
     * @param name Name of the view
     * @param body View configuration in config.xml format
     * @param jenkinsCrumb CSRF protection token
     */
    postViewConfig(params: {  name: string; body: string; jenkinsCrumb?: string; }, options: any = {}) {
        return RemoteAccessApiFp.postViewConfig(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * RemoteAccessApi - factory interface
 */
export const RemoteAccessApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieve computer details
         * @param depth Recursion depth in response model
         */
        getComputer(params: {  depth: number; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getComputer(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve CSRF protection token
         */
        getCrumb(configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getCrumb(configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve Jenkins details
         */
        getJenkins(configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getJenkins(configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve job details
         * @param name Name of the job
         */
        getJob(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getJob(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve job configuration
         * @param name Name of the job
         */
        getJobConfig(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getJobConfig(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve job's last build details
         * @param name Name of the job
         */
        getJobLastBuild(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getJobLastBuild(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve job's build progressive text output
         * @param name Name of the job
         * @param number Build number
         * @param start Starting point of progressive text output
         */
        getJobProgressiveText(params: {  name: string; number: string; start: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getJobProgressiveText(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve queue details
         */
        getQueue(configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getQueue(configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve queued item details
         * @param number Queue number
         */
        getQueueItem(params: {  number: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getQueueItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve view details
         * @param name Name of the view
         */
        getView(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getView(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve view configuration
         * @param name Name of the view
         */
        getViewConfig(params: {  name: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.getViewConfig(params, configuration, options)(fetch, basePath);
        },
        /**
         * Retrieve Jenkins headers
         */
        headJenkins(configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.headJenkins(configuration, options)(fetch, basePath);
        },
        /**
         * Create a new job using job configuration, or copied from an existing job
         * @param name Name of the new job
         * @param from Existing job to copy from
         * @param mode Set to &#39;copy&#39; for copying an existing job
         * @param body Job configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         * @param contentType Content type header application/xml
         */
        postCreateItem(params: {  name: string; from?: string; mode?: string; body?: string; jenkinsCrumb?: string; contentType?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postCreateItem(params, configuration, options)(fetch, basePath);
        },
        /**
         * Create a new view using view configuration
         * @param name Name of the new view
         * @param body View configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         * @param contentType Content type header application/xml
         */
        postCreateView(params: {  name: string; body?: string; jenkinsCrumb?: string; contentType?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postCreateView(params, configuration, options)(fetch, basePath);
        },
        /**
         * Build a job
         * @param name Name of the job
         * @param json 
         * @param token 
         * @param jenkinsCrumb CSRF protection token
         */
        postJobBuild(params: {  name: string; json: string; token?: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postJobBuild(params, configuration, options)(fetch, basePath);
        },
        /**
         * Update job configuration
         * @param name Name of the job
         * @param body Job configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         */
        postJobConfig(params: {  name: string; body: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postJobConfig(params, configuration, options)(fetch, basePath);
        },
        /**
         * Delete a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobDelete(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postJobDelete(params, configuration, options)(fetch, basePath);
        },
        /**
         * Disable a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobDisable(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postJobDisable(params, configuration, options)(fetch, basePath);
        },
        /**
         * Enable a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobEnable(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postJobEnable(params, configuration, options)(fetch, basePath);
        },
        /**
         * Stop a job
         * @param name Name of the job
         * @param jenkinsCrumb CSRF protection token
         */
        postJobLastBuildStop(params: {  name: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postJobLastBuildStop(params, configuration, options)(fetch, basePath);
        },
        /**
         * Update view configuration
         * @param name Name of the view
         * @param body View configuration in config.xml format
         * @param jenkinsCrumb CSRF protection token
         */
        postViewConfig(params: {  name: string; body: string; jenkinsCrumb?: string; }, configuration: Configuration, options: any = {}) {
            return RemoteAccessApiFp.postViewConfig(params, configuration, options)(fetch, basePath);
        },
    };
};

