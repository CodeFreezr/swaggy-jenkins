/**
* Swaggy Jenkins
* Jenkins API clients generated from Swagger / Open API specification
*
* OpenAPI spec version: 0.1.0
* Contact: blah@cliffano.com
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.HudsonmodelComputerSet
import io.swagger.client.models.HudsonmodelFreeStyleBuild
import io.swagger.client.models.HudsonmodelFreeStyleProject
import io.swagger.client.models.HudsonmodelHudson
import io.swagger.client.models.HudsonmodelListView
import io.swagger.client.models.HudsonmodelQueue
import io.swagger.client.models.HudsonsecuritycsrfDefaultCrumbIssuer

import io.swagger.client.infrastructure.*

class RemoteAccessApi(basePath: kotlin.String = "http://localhost") : ApiClient(basePath) {

    /**
    * 
    * Retrieve computer details
    * @return HudsonmodelComputerSet
    */
    @Suppress("UNCHECKED_CAST")
    fun getComputer() : HudsonmodelComputerSet {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/computer/api/json?depth&#x3D;1",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelComputerSet>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelComputerSet
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve CSRF protection token
    * @return HudsonsecuritycsrfDefaultCrumbIssuer
    */
    @Suppress("UNCHECKED_CAST")
    fun getCrumb() : HudsonsecuritycsrfDefaultCrumbIssuer {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/crumbIssuer/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonsecuritycsrfDefaultCrumbIssuer>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonsecuritycsrfDefaultCrumbIssuer
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve Jenkins details
    * @return HudsonmodelHudson
    */
    @Suppress("UNCHECKED_CAST")
    fun getJenkins() : HudsonmodelHudson {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelHudson>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelHudson
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve job details
    * @param name Name of the job 
    * @return HudsonmodelFreeStyleProject
    */
    @Suppress("UNCHECKED_CAST")
    fun getJob(name: kotlin.String) : HudsonmodelFreeStyleProject {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/job/{name}/api/json".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelFreeStyleProject>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelFreeStyleProject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve job configuration
    * @param name Name of the job 
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun getJobConfig(name: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/job/{name}/config.xml".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve job&#39;s last build details
    * @param name Name of the job 
    * @return HudsonmodelFreeStyleBuild
    */
    @Suppress("UNCHECKED_CAST")
    fun getJobLastBuild(name: kotlin.String) : HudsonmodelFreeStyleBuild {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/job/{name}/lastBuild/api/json".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelFreeStyleBuild>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelFreeStyleBuild
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve job&#39;s build progressive text output
    * @param name Name of the job 
    * @param number Build number 
    * @param start Starting point of progressive text output 
    * @return void
    */
    fun getJobProgressiveText(name: kotlin.String, number: kotlin.String, start: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("start" to start)
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/job/{name}/{number}/logText/progressiveText".replace("{"+"name"+"}", "$name").replace("{"+"number"+"}", "$number"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve queue details
    * @return HudsonmodelQueue
    */
    @Suppress("UNCHECKED_CAST")
    fun getQueue() : HudsonmodelQueue {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/queue/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelQueue>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelQueue
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve queued item details
    * @param number Queue number 
    * @return HudsonmodelQueue
    */
    @Suppress("UNCHECKED_CAST")
    fun getQueueItem(number: kotlin.String) : HudsonmodelQueue {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/queue/item/{number}/api/json".replace("{"+"number"+"}", "$number"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelQueue>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelQueue
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve view details
    * @param name Name of the view 
    * @return HudsonmodelListView
    */
    @Suppress("UNCHECKED_CAST")
    fun getView(name: kotlin.String) : HudsonmodelListView {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/view/{name}/api/json".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<HudsonmodelListView>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as HudsonmodelListView
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve view configuration
    * @param name Name of the view 
    * @return kotlin.String
    */
    @Suppress("UNCHECKED_CAST")
    fun getViewConfig(name: kotlin.String) : kotlin.String {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/view/{name}/config.xml".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.String>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.String
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Retrieve Jenkins headers
    * @return void
    */
    fun headJenkins() : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.HEAD,
            "/api/json",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Create a new job using job configuration, or copied from an existing job
    * @param name Name of the new job 
    * @param from Existing job to copy from (optional)
    * @param mode Set to &#39;copy&#39; for copying an existing job (optional)
    * @param body Job configuration in config.xml format (optional)
    * @param jenkinsCrumb CSRF protection token (optional)
    * @param contentType Content type header application/xml (optional)
    * @return void
    */
    fun postCreateItem(name: kotlin.String, from: kotlin.String, mode: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String, contentType: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("name" to name, "from" to from, "mode" to mode)
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)mapOf("contentType" to contentType)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/createItem",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Create a new view using view configuration
    * @param name Name of the new view 
    * @param body View configuration in config.xml format (optional)
    * @param jenkinsCrumb CSRF protection token (optional)
    * @param contentType Content type header application/xml (optional)
    * @return void
    */
    fun postCreateView(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String, contentType: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("name" to name)
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)mapOf("contentType" to contentType)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/createView",
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Build a job
    * @param name Name of the job 
    * @param json  
    * @param token  (optional)
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postJobBuild(name: kotlin.String, json: kotlin.String, token: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("json" to json, "token" to token)
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/job/{name}/build".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Update job configuration
    * @param name Name of the job 
    * @param body Job configuration in config.xml format 
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postJobConfig(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/job/{name}/config.xml".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Delete a job
    * @param name Name of the job 
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postJobDelete(name: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/job/{name}/doDelete".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Disable a job
    * @param name Name of the job 
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postJobDisable(name: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/job/{name}/disable".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Enable a job
    * @param name Name of the job 
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postJobEnable(name: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/job/{name}/enable".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Stop a job
    * @param name Name of the job 
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postJobLastBuildStop(name: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/job/{name}/lastBuild/stop".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * 
    * Update view configuration
    * @param name Name of the view 
    * @param body View configuration in config.xml format 
    * @param jenkinsCrumb CSRF protection token (optional)
    * @return void
    */
    fun postViewConfig(name: kotlin.String, body: kotlin.String, jenkinsCrumb: kotlin.String) : Unit {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf("jenkinsCrumb" to jenkinsCrumb)
        val localVariableConfig = RequestConfig(
            RequestMethod.POST,
            "/view/{name}/config.xml".replace("{"+"name"+"}", "$name"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Any?>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }


    private fun collectionDelimiter(collectionFormat: kotlin.String) = when(collectionFormat) {
        "csv" -> ","
        "tsv" -> "\t"
        "pipes" -> "|"
        "ssv" -> " "
        else -> ""
    }
}
