/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class BlueOceanApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * 
     * Retrieve authenticated user details for an organisation
     * @param organisation Name of the organisation
     */
    public getAuthenticatedUser(organisation: string, extraHttpRequestParams?: any): Observable<models.SwaggyjenkinsUser> {
        return this.getAuthenticatedUserWithHttpInfo(organisation, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    public getClasses(_class: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getClassesWithHttpInfo(_class, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve organisation details
     * @param organisation Name of the organisation
     */
    public getOrganisation(organisation: string, extraHttpRequestParams?: any): Observable<models.SwaggyjenkinsOrganisation> {
        return this.getOrganisationWithHttpInfo(organisation, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve all organisations details
     */
    public getOrganisations(extraHttpRequestParams?: any): Observable<models.GetOrganisations> {
        return this.getOrganisationsWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve branch details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    public getPipelineBranchByOrg(organisation: string, pipeline: string, branch: string, extraHttpRequestParams?: any): Observable<models.IojenkinsblueoceanrestimplpipelineBranchImpl> {
        return this.getPipelineBranchByOrgWithHttpInfo(organisation, pipeline, branch, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve all branches details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    public getPipelineBranchesByOrg(organisation: string, pipeline: string, extraHttpRequestParams?: any): Observable<models.GetMultibranchPipeline> {
        return this.getPipelineBranchesByOrgWithHttpInfo(organisation, pipeline, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve pipeline details for an organisation
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    public getPipelineByOrg(organisation: string, pipeline: string, extraHttpRequestParams?: any): Observable<models.SwaggyjenkinsPipeline> {
        return this.getPipelineByOrgWithHttpInfo(organisation, pipeline, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve pipeline folder for an organisation
     * @param organisation Name of the organisation
     * @param folder Name of the folder
     */
    public getPipelineFolderByOrg(organisation: string, folder: string, extraHttpRequestParams?: any): Observable<models.IojenkinsblueoceanserviceembeddedrestPipelineFolderImpl> {
        return this.getPipelineFolderByOrgWithHttpInfo(organisation, folder, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve pipeline details for an organisation folder
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    public getPipelineFolderByOrg_1(organisation: string, pipeline: string, folder: string, extraHttpRequestParams?: any): Observable<models.IojenkinsblueoceanserviceembeddedrestPipelineImpl> {
        return this.getPipelineFolderByOrg_1WithHttpInfo(organisation, pipeline, folder, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve all pipelines details for an organisation
     * @param organisation Name of the organisation
     */
    public getPipelinesByOrg(organisation: string, extraHttpRequestParams?: any): Observable<models.GetPipelines> {
        return this.getPipelinesByOrgWithHttpInfo(organisation, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve user details for an organisation
     * @param organisation Name of the organisation
     * @param user Name of the user
     */
    public getUser(organisation: string, user: string, extraHttpRequestParams?: any): Observable<models.SwaggyjenkinsUser> {
        return this.getUserWithHttpInfo(organisation, user, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Retrieve users details for an organisation
     * @param organisation Name of the organisation
     */
    public getUsers(organisation: string, extraHttpRequestParams?: any): Observable<models.SwaggyjenkinsUser> {
        return this.getUsersWithHttpInfo(organisation, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Get classes details
     * @param q Query string containing an array of class names
     */
    public search(q: string, extraHttpRequestParams?: any): Observable<string> {
        return this.searchWithHttpInfo(q, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * 
     * Search for any resource details
     * @param q Query string
     */
    public search_2(q: string, extraHttpRequestParams?: any): Observable<string> {
        return this.search_2WithHttpInfo(q, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * 
     * Retrieve authenticated user details for an organisation
     * @param organisation Name of the organisation
     */
    public getAuthenticatedUserWithHttpInfo(organisation: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/user/'
                    .replace('${' + 'organisation' + '}', String(organisation));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getAuthenticatedUser.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Get a list of class names supported by a given class
     * @param _class Name of the class
     */
    public getClassesWithHttpInfo(_class: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/classes/${class}'
                    .replace('${' + 'class' + '}', String(_class));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter '_class' is not null or undefined
        if (_class === null || _class === undefined) {
            throw new Error('Required parameter _class was null or undefined when calling getClasses.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve organisation details
     * @param organisation Name of the organisation
     */
    public getOrganisationWithHttpInfo(organisation: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}'
                    .replace('${' + 'organisation' + '}', String(organisation));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getOrganisation.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve all organisations details
     */
    public getOrganisationsWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve branch details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param branch Name of the branch
     */
    public getPipelineBranchByOrgWithHttpInfo(organisation: string, pipeline: string, branch: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/pipelines/${pipeline}/branches/${branch}/'
                    .replace('${' + 'organisation' + '}', String(organisation))
                    .replace('${' + 'pipeline' + '}', String(pipeline))
                    .replace('${' + 'branch' + '}', String(branch));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineBranchByOrg.');
        }
        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranchByOrg.');
        }
        // verify required parameter 'branch' is not null or undefined
        if (branch === null || branch === undefined) {
            throw new Error('Required parameter branch was null or undefined when calling getPipelineBranchByOrg.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve all branches details for an organisation pipeline
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    public getPipelineBranchesByOrgWithHttpInfo(organisation: string, pipeline: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/pipelines/${pipeline}/branches'
                    .replace('${' + 'organisation' + '}', String(organisation))
                    .replace('${' + 'pipeline' + '}', String(pipeline));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineBranchesByOrg.');
        }
        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineBranchesByOrg.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve pipeline details for an organisation
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     */
    public getPipelineByOrgWithHttpInfo(organisation: string, pipeline: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/pipelines/${pipeline}'
                    .replace('${' + 'organisation' + '}', String(organisation))
                    .replace('${' + 'pipeline' + '}', String(pipeline));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineByOrg.');
        }
        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineByOrg.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve pipeline folder for an organisation
     * @param organisation Name of the organisation
     * @param folder Name of the folder
     */
    public getPipelineFolderByOrgWithHttpInfo(organisation: string, folder: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/pipelines/${folder}/'
                    .replace('${' + 'organisation' + '}', String(organisation))
                    .replace('${' + 'folder' + '}', String(folder));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineFolderByOrg.');
        }
        // verify required parameter 'folder' is not null or undefined
        if (folder === null || folder === undefined) {
            throw new Error('Required parameter folder was null or undefined when calling getPipelineFolderByOrg.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve pipeline details for an organisation folder
     * @param organisation Name of the organisation
     * @param pipeline Name of the pipeline
     * @param folder Name of the folder
     */
    public getPipelineFolderByOrg_1WithHttpInfo(organisation: string, pipeline: string, folder: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/pipelines/${folder}/pipelines/${pipeline}'
                    .replace('${' + 'organisation' + '}', String(organisation))
                    .replace('${' + 'pipeline' + '}', String(pipeline))
                    .replace('${' + 'folder' + '}', String(folder));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelineFolderByOrg_1.');
        }
        // verify required parameter 'pipeline' is not null or undefined
        if (pipeline === null || pipeline === undefined) {
            throw new Error('Required parameter pipeline was null or undefined when calling getPipelineFolderByOrg_1.');
        }
        // verify required parameter 'folder' is not null or undefined
        if (folder === null || folder === undefined) {
            throw new Error('Required parameter folder was null or undefined when calling getPipelineFolderByOrg_1.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve all pipelines details for an organisation
     * @param organisation Name of the organisation
     */
    public getPipelinesByOrgWithHttpInfo(organisation: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/pipelines/'
                    .replace('${' + 'organisation' + '}', String(organisation));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getPipelinesByOrg.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve user details for an organisation
     * @param organisation Name of the organisation
     * @param user Name of the user
     */
    public getUserWithHttpInfo(organisation: string, user: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/users/${user}'
                    .replace('${' + 'organisation' + '}', String(organisation))
                    .replace('${' + 'user' + '}', String(user));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getUser.');
        }
        // verify required parameter 'user' is not null or undefined
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getUser.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Retrieve users details for an organisation
     * @param organisation Name of the organisation
     */
    public getUsersWithHttpInfo(organisation: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/organizations/${organisation}/users/'
                    .replace('${' + 'organisation' + '}', String(organisation));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'organisation' is not null or undefined
        if (organisation === null || organisation === undefined) {
            throw new Error('Required parameter organisation was null or undefined when calling getUsers.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Get classes details
     * @param q Query string containing an array of class names
     */
    public searchWithHttpInfo(q: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/classes/';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling search.');
        }
        if (q !== undefined) {
            queryParameters.set('q', <any>q);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * Search for any resource details
     * @param q Query string
     */
    public search_2WithHttpInfo(q: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/blue/rest/search/';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'q' is not null or undefined
        if (q === null || q === undefined) {
            throw new Error('Required parameter q was null or undefined when calling search_2.');
        }
        if (q !== undefined) {
            queryParameters.set('q', <any>q);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
