/**
 * Swaggy Jenkins
 * Jenkins API clients generated from Swagger / Open API specification
 *
 * OpenAPI spec version: 0.1.0
 * Contact: blah@cliffano.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.api

import io.swagger.client.model.HudsonmodelComputerSet
import io.swagger.client.model.HudsonmodelFreeStyleBuild
import io.swagger.client.model.HudsonmodelFreeStyleProject
import io.swagger.client.model.HudsonmodelHudson
import io.swagger.client.model.HudsonmodelListView
import io.swagger.client.model.HudsonmodelQueue
import io.swagger.client.model.HudsonsecuritycsrfDefaultCrumbIssuer
import io.swagger.client.ApiInvoker
import io.swagger.client.ApiException

import com.sun.jersey.multipart.FormDataMultiPart
import com.sun.jersey.multipart.file.FileDataBodyPart

import javax.ws.rs.core.MediaType

import java.io.File
import java.util.Date

import scala.collection.mutable.HashMap

class RemoteAccessApi(val defBasePath: String = "http://localhost",
                        defApiInvoker: ApiInvoker = ApiInvoker) {
  var basePath = defBasePath
  var apiInvoker = defApiInvoker

  def addHeader(key: String, value: String) = apiInvoker.defaultHeaders += key -> value 

  /**
   * 
   * Retrieve computer details
   * @return HudsonmodelComputerSet
   */
  def getComputer(): Option[HudsonmodelComputerSet] = {
    // create path and map variables
    val path = "/computer/api/json?depth=1".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelComputerSet]).asInstanceOf[HudsonmodelComputerSet])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve CSRF protection token
   * @return HudsonsecuritycsrfDefaultCrumbIssuer
   */
  def getCrumb(): Option[HudsonsecuritycsrfDefaultCrumbIssuer] = {
    // create path and map variables
    val path = "/crumbIssuer/api/json".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonsecuritycsrfDefaultCrumbIssuer]).asInstanceOf[HudsonsecuritycsrfDefaultCrumbIssuer])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve Jenkins details
   * @return HudsonmodelHudson
   */
  def getJenkins(): Option[HudsonmodelHudson] = {
    // create path and map variables
    val path = "/api/json".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelHudson]).asInstanceOf[HudsonmodelHudson])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve job details
   * @param name Name of the job 
   * @return HudsonmodelFreeStyleProject
   */
  def getJob(name: String): Option[HudsonmodelFreeStyleProject] = {
    // create path and map variables
    val path = "/job/{name}/api/json".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->getJob")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelFreeStyleProject]).asInstanceOf[HudsonmodelFreeStyleProject])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve job configuration
   * @param name Name of the job 
   * @return String
   */
  def getJobConfig(name: String): Option[String] = {
    // create path and map variables
    val path = "/job/{name}/config.xml".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->getJobConfig")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve job&#39;s last build details
   * @param name Name of the job 
   * @return HudsonmodelFreeStyleBuild
   */
  def getJobLastBuild(name: String): Option[HudsonmodelFreeStyleBuild] = {
    // create path and map variables
    val path = "/job/{name}/lastBuild/api/json".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->getJobLastBuild")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelFreeStyleBuild]).asInstanceOf[HudsonmodelFreeStyleBuild])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve job&#39;s build progressive text output
   * @param name Name of the job 
   * @param number Build number 
   * @param start Starting point of progressive text output 
   * @return void
   */
  def getJobProgressiveText(name: String, number: String, start: String) = {
    // create path and map variables
    val path = "/job/{name}/{number}/logText/progressiveText".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name)).replaceAll("\\{" + "number" + "\\}",apiInvoker.escape(number))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->getJobProgressiveText")

    if (number == null) throw new Exception("Missing required parameter 'number' when calling RemoteAccessApi->getJobProgressiveText")

    if (start == null) throw new Exception("Missing required parameter 'start' when calling RemoteAccessApi->getJobProgressiveText")

    queryParams += "start" -> start.toString
    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve queue details
   * @return HudsonmodelQueue
   */
  def getQueue(): Option[HudsonmodelQueue] = {
    // create path and map variables
    val path = "/queue/api/json".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelQueue]).asInstanceOf[HudsonmodelQueue])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve queued item details
   * @param number Queue number 
   * @return HudsonmodelQueue
   */
  def getQueueItem(number: String): Option[HudsonmodelQueue] = {
    // create path and map variables
    val path = "/queue/item/{number}/api/json".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "number" + "\\}",apiInvoker.escape(number))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (number == null) throw new Exception("Missing required parameter 'number' when calling RemoteAccessApi->getQueueItem")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelQueue]).asInstanceOf[HudsonmodelQueue])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve view details
   * @param name Name of the view 
   * @return HudsonmodelListView
   */
  def getView(name: String): Option[HudsonmodelListView] = {
    // create path and map variables
    val path = "/view/{name}/api/json".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->getView")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[HudsonmodelListView]).asInstanceOf[HudsonmodelListView])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve view configuration
   * @param name Name of the view 
   * @return String
   */
  def getViewConfig(name: String): Option[String] = {
    // create path and map variables
    val path = "/view/{name}/config.xml".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->getViewConfig")

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "GET", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
           Some(apiInvoker.deserialize(s, "", classOf[String]).asInstanceOf[String])
        case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Retrieve Jenkins headers
   * @return void
   */
  def headJenkins() = {
    // create path and map variables
    val path = "/api/json".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "HEAD", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Create a new job using job configuration, or copied from an existing job
   * @param name Name of the new job 
   * @param from Existing job to copy from (optional)
   * @param mode Set to &#39;copy&#39; for copying an existing job (optional)
   * @param body Job configuration in config.xml format (optional)
   * @param jenkinsCrumb CSRF protection token (optional)
   * @param _contentType Content type header application/xml (optional)
   * @return void
   */
  def postCreateItem(name: String, from: Option[String] = None, mode: Option[String] = None, body: Option[String] = None, jenkinsCrumb: Option[String] = None, _contentType: Option[String] = None) = {
    // create path and map variables
    val path = "/createItem".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postCreateItem")

    queryParams += "name" -> name.toString
    from.map(paramVal => queryParams += "from" -> paramVal.toString)
    mode.map(paramVal => queryParams += "mode" -> paramVal.toString)
    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)
    _contentType.map(paramVal => headerParams += "Content-Type" -> paramVal)

    var postBody: AnyRef = body.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Create a new view using view configuration
   * @param name Name of the new view 
   * @param body View configuration in config.xml format (optional)
   * @param jenkinsCrumb CSRF protection token (optional)
   * @param _contentType Content type header application/xml (optional)
   * @return void
   */
  def postCreateView(name: String, body: Option[String] = None, jenkinsCrumb: Option[String] = None, _contentType: Option[String] = None) = {
    // create path and map variables
    val path = "/createView".replaceAll("\\{format\\}", "json")

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postCreateView")

    queryParams += "name" -> name.toString
    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)
    _contentType.map(paramVal => headerParams += "Content-Type" -> paramVal)

    var postBody: AnyRef = body.map(paramVal => paramVal)

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Build a job
   * @param name Name of the job 
   * @param json  
   * @param token  (optional)
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postJobBuild(name: String, json: String, token: Option[String] = None, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/job/{name}/build".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postJobBuild")

    if (json == null) throw new Exception("Missing required parameter 'json' when calling RemoteAccessApi->postJobBuild")

    queryParams += "json" -> json.toString
    token.map(paramVal => queryParams += "token" -> paramVal.toString)
    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Update job configuration
   * @param name Name of the job 
   * @param body Job configuration in config.xml format 
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postJobConfig(name: String, body: String, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/job/{name}/config.xml".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postJobConfig")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling RemoteAccessApi->postJobConfig")

    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Delete a job
   * @param name Name of the job 
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postJobDelete(name: String, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/job/{name}/doDelete".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postJobDelete")

    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Disable a job
   * @param name Name of the job 
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postJobDisable(name: String, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/job/{name}/disable".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postJobDisable")

    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Enable a job
   * @param name Name of the job 
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postJobEnable(name: String, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/job/{name}/enable".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postJobEnable")

    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Stop a job
   * @param name Name of the job 
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postJobLastBuildStop(name: String, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/job/{name}/lastBuild/stop".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postJobLastBuildStop")

    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = null

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

  /**
   * 
   * Update view configuration
   * @param name Name of the view 
   * @param body View configuration in config.xml format 
   * @param jenkinsCrumb CSRF protection token (optional)
   * @return void
   */
  def postViewConfig(name: String, body: String, jenkinsCrumb: Option[String] = None) = {
    // create path and map variables
    val path = "/view/{name}/config.xml".replaceAll("\\{format\\}", "json").replaceAll("\\{" + "name" + "\\}",apiInvoker.escape(name))

    val contentTypes = List("application/json")
    val contentType = contentTypes(0)

    val queryParams = new HashMap[String, String]
    val headerParams = new HashMap[String, String]
    val formParams = new HashMap[String, String]

    if (name == null) throw new Exception("Missing required parameter 'name' when calling RemoteAccessApi->postViewConfig")

    if (body == null) throw new Exception("Missing required parameter 'body' when calling RemoteAccessApi->postViewConfig")

    
    jenkinsCrumb.map(paramVal => headerParams += "Jenkins-Crumb" -> paramVal)

    var postBody: AnyRef = body

    if (contentType.startsWith("multipart/form-data")) {
      val mp = new FormDataMultiPart
      postBody = mp
    } else {
    }

    try {
      apiInvoker.invokeApi(basePath, path, "POST", queryParams.toMap, formParams.toMap, postBody, headerParams.toMap, contentType) match {
        case s: String =>
                  case _ => None
      }
    } catch {
      case ex: ApiException if ex.code == 404 => None
      case ex: ApiException => throw ex
    }
  }

}
